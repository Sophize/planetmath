{
  "alternatePhrases": [],
  "definition": "A *regular expression* is a particular meta-syntax for specifying\nregular grammars, which has many useful applications.\n\nWhile variations abound, fundamentally a regular expression consists of\nthe following pieces:\n\n-   Parentheses can be used for grouping and nesting, and must contain a\n    fully-formed regular expression.\n\n-   The `|` symbol can be used for denoting alternatives. Some\n    specifications do not provide nesting or alternatives.\n\n-   There are also a number of postfix operators. The `?` operator means\n    that the preceding element can either be present or non-present, and\n    corresponds to a rule of the form $A\\to B\\,|\\,\\lambda$.\n\n-   The `*` operator means that the preceding element can be present\n    zero or more times, and corresponds to a rule of the form\n    $A\\to BA\\,|\\,\\lambda$.\n\n-   The `+` operator means that the preceding element can be present one\n    or more times, and corresponds to a rule of the form\n    $A\\to BA\\,|\\,B$.\n\nNote that while these rules are not immediately in regular form, they\ncan be transformed so that they are.\n\nFormally, let $S=\\lbrace \\varnothing, \\cup, ^*, (, )\\rbrace$ and\n$\\Sigma$ an alphabet disjoint from $S$. Consider the language\n$L(\\Sigma)$ over $\\Sigma\\cup S$ specified below\n\n1.  $\\varnothing\\in L(\\Sigma)$,\n\n2.  $a\\in L(\\Sigma)$ for each $a\\in \\Sigma$,\n\n3.  if $u\\in L(\\Sigma)$, then $u^*\\in L(\\Sigma)$,\n\n4.  if $u_1,u_2\\in L(\\Sigma)$, then $(u_1\\cup u_2)$ and $(u_1u_2)$ are\n    both in $L(\\Sigma)$, and\n\n5.  among all languages over $\\Sigma\\cup S$ satisfying conditions 1-4,\n    $L(\\Sigma)$ is the smallest.\n\nThen any element $u\\in L(\\Sigma)$ is called a *regular expression* over\n$\\Sigma$.\n\nHere is an example of a regular expression that specifies a grammar that\ngenerates the binary representation of all multiples of 3 (and only\nmultiples of 3).\n\n$$(0^*(1(01^*0)^*1)^*)^*0^*$$\n\nThis specifies the context-free grammar (in BNF):\n\n$$\\begin{aligned}\nS & \\verb.::=. & AB \\\\\nA & \\verb.::=. & CD \\\\\nB & \\verb.::=. & \\verb=0=B | \\lambda \\\\\nC & \\verb.::=. & \\verb=0=C | \\lambda \\\\\nD & \\verb.::=. & \\verb=1=E\\verb=1= \\\\\nE & \\verb.::=. & FE | \\lambda \\\\\nF & \\verb.::=. & \\verb=0=G\\verb=0= \\\\\nG & \\verb.::=. & \\verb=1=G | \\lambda \\end{aligned}$$\n\nA little further work is required to transform this grammar into an\nacceptable form for regular grammars, but it can be shown that this\ngrammar (and any grammar specified by a regular expression) is\nequivalent to some regular grammar.\n\nOne can understand the language described by a regular expression in\nanother way, by viewing the regular expression operators as shorthand\nfor various set-theoretic operations. Formally, the *language $L(u)$\nover $\\Sigma$ associated with a regular expression* $u$ over $\\Sigma$ is\ninductively defined as follows:\n\n-   $L(\\varnothing)=\\varnothing$,\n\n-   $L(a)=\\lbrace a\\rbrace$ whenever $a\\in \\Sigma$,\n\n-   $L(u^*)=L(u)^*$, where the $^*$ on the right side is the Kleene star\n    operation on sets,\n\n-   $L((u_1u_2))=L(u_1)L(u_2)$, where the right side denotes the\n    concatenation of two sets, and\n\n-   $L((u_1\\cup u_2))=L(u_1)\\cup L(u_2)$, where $\\cup$ on the right side\n    is the union operation on sets.\n\nA language $L$ over $\\Sigma$ is regular iff there is a regular\nexpression $u$ over $\\Sigma$ such that $L=L(u)$.\n\nWith this interpretation, it is quite straightforward to design a\nnon-deterministic finite automaton that recognizes the language\ndescribed by a regular expression. Of course, for computer\nimplementations, one must transform this into a deterministic finite\nautomaton, but there are various algorithms for doing this efficiently.\nThis process, production of a non-deterministic automaton and conversion\nto an equivalent deterministic automaton is approximately what is done\nin software packages implementing regular expression searching. In fact,\nmost such packages implement operations impossible for a finite\nautomaton, such as requiring a later part of the string to be the same\nas a previous part (the language $\\{A^nBA^n\\text{ for }n\\geq 0\\}$ is not\nregular but can be matched by most \u201cregular expression\u201d software; such\ncapabilities are called \u201cextended regular expressions\u201d. None of these\nsystems are powerful enough to recognize the language of balanced\nparentheses.\n\nRegular expressions have many applications. Quite often they are used\nfor powerful string matching and substitution features in many text\neditors and programming languages.",
  "language": "INFORMAL",
  "phrase": "Regular Expression",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/RegularExpression"
    }
  ],
  "indexable": true
}