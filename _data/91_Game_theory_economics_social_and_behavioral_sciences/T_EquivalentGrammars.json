{
  "alternatePhrases": [],
  "definition": "Two formal grammars $G_1=(\\Sigma_1,N_1,P_1,\\sigma_1)$ and\n$G_2=(\\Sigma_2,N_2,P_2,\\sigma_2)$ are said to be *equivalent* if they\ngenerate the same formal languages: $$L(G_1)=L(G_2).$$ When two grammars\n$G_1$ and $G_2$ are equivalent, we write $G_1\\cong G_2$.\n\nFor example, the language\n$\\lbrace a^nb^{2n}\\mid n\\mbox{ is a non-negative integer}\\rbrace$ over\n$T=\\lbrace a,b,c\\rbrace$ can be generated by a grammar $G_1$ with three\nnon-terminals $x,y,\\sigma$, and the following productions:\n$$P_1=\\lbrace \\sigma \\to \\lambda, \\sigma \\to x\\sigma y, x\\to a, y\\to b^2 \\rbrace.$$\nAlternatively, it can be generated by a simpler grammar $G_2$ with just\nthe starting symbol:\n$$P_2=\\lbrace \\sigma \\to \\lambda, \\sigma \\to a\\sigma b^2\\rbrace.$$ This\nshows that $G_1 \\cong G_2$.\n\nAn alternative way of writing a grammar $G$ is $(T,N,P,\\sigma)$, where\n$T=\\Sigma-N$ is the set of terminals of $G$. Suppose\n$G_1=(T_1,N_1,P_1,\\sigma_1)$ and $G_2=(T_2,N_2,P_2,\\sigma_2)$ are two\ngrammars. Below are some basic properties of equivalence of grammars:\n\n1.  Suppose $G_1\\cong G_2$. If $T_1\\cap T_2=\\varnothing$, then\n    $L(G_1)=\\varnothing$.\n\n2.  Let $G=(T,N,P,\\sigma)$ be a grammar. Then the grammar\n    $G'=(T,N',P,\\sigma)$ where $N\\subseteq N'$ is equivalent to $G$.\n\n3.  If $(T_1,N_1,P_1,\\sigma_1)\\cong (T_1,N_1,P_2,\\sigma_2)$, then\n    $(T,N,P_1,\\sigma_1)\\cong (T,N,P_2,\\sigma_2)$, where $T=T_1\\cup T_2$\n    and $N=N_1\\cup N_2$.\n\n4.  If we fix an alphabet $\\Sigma$, then $\\cong$ is an equivalence\n    relation on grammars over $\\Sigma$.\n\nSo far, the properties have all been focused on the underlying\nalphabets. More interesting properties on equivalent grammars center on\nproductions. Suppose $G=(\\Sigma,N,P,\\sigma)$ is a grammar.\n\n1.  A production is said to be trivial if it has the form $v\\to v$. Then\n    the grammar $G'$ obtained by adding trivial productions to $P$ is\n    equivalent to $G$.\n\n2.  If $u\\in L(G)$, then adding the production $\\sigma\\to u$ to $P$\n    produces a grammar equivalent to $G$.\n\n3.  Call a production a *filler* if it has the form $\\lambda \\to v$.\n    Replacing a filler $\\lambda \\to v$ by productions $a\\to va$ and\n    $a\\to av$ using all symbols $a\\in \\Sigma$ gives us a grammar that is\n    equivalent to $G$.\n\n4.  $G$ is equivalent to a grammar $G'$ without any fillers. This can be\n    done by replacing each filler using the productions mentioned in the\n    previous section. Finally, if $\\lambda\\in L(G)$, we add the\n    production $\\sigma \\to \\lambda$ to $P$ if it were not already in\n    $P$.\n\n5.  Let $S(P)$ be the set of all symbols that occur in the productions\n    in $P$ (in either antecedents or conseqents). If $a\\in S(P)$, then\n    $G'$ obtained by replacing every production $u\\to v \\in P$ with\n    production $u[a/b]\\to v[a/b]$ and $b\\to a$, with a symbol\n    $X\\notin \\Sigma$, is equivalent to $G$. Here, $u[a/b]$ means that we\n    replace each occurrence of $a$ in $u$ with $X$.\n\n6.  $G$ is equivalent to a grammar $G'$, all of whose productions have\n    antecedents in $N^+$ (non-empty words over $N$).\n\n**Remark**. In fact, if we let\n\n1.  $X\\to XY$,\n\n2.  $XY\\to ZT$,\n\n3.  $X\\to \\lambda$,\n\n4.  $X\\to a$\n\nbe four types of productions, then it can be shown that\n\n-   any formal grammar is equivalent to a grammar all of whose\n    productions are in any of the four forms above\n\n-   any context-sensitive grammar is equivalent to a grammar all of\n    whose productions are in any of forms 1, 2, or 4, and\n\n-   and any context-free grammar is equivalent to a grammar all of whose\n    productions are in any of forms 1, 3, or 4.\n\n[9]{} A. Salomaa [*Computation and Automata, Encyclopedia of Mathematics\nand Its Applications, Vol. 25*]{}. Cambridge (1985).",
  "language": "INFORMAL",
  "phrase": "Equivalent Grammars",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/EquivalentGrammars"
    }
  ],
  "indexable": true
}