{
  "alternatePhrases": [
    "URM-computable"
  ],
  "definition": "Let $M$ be an unlimited register machine (URM), and $r$ a finite\nsequence of non-negative integers. Recall the following notations:\n\n-   $M(r)$ denotes the computation of $r$ by the program of $M$,\n\n-   $M(r)\\!\\downarrow$ denotes that the computation halts ($M$ converges\n    on $r$),\n\n-   $M(r)\\!\\downarrow a$ denotes $M(r)\\!\\downarrow$, and $a$ is the\n    content of register 1 in the output,\n\n-   $M(r)\\!\\uparrow$ denotes that the computation does not halt ($M$\n    diverges $r$).\n\nIn the case where all but finitely many values of $r$ are $0$, say\n$r=r_1, r_2, \\ldots, r_n, 0, 0, \\ldots$, we also write\n$M(r_1,\\ldots,r_n)$ to emphasize the fact that $r_i=0$ for all $i>n$.\n\n**Definition**. Let $f: \\mathbb{N}^n \\to \\mathbb{N}$ be an $n$-ary\npartial function on natural numbers (including $0$ in this discussion).\n$f$ is said to be *URM-computable* if there is a URM $M$ such that\n$M(r_1,\\ldots,r_n)\\!\\downarrow f(r_1,\\ldots, r_n)$ precisely when\n$(r_1,\\ldots,r_n)\\in \\operatorname{dom}(f)$. When $f$ is URM-computable\nby $M$, we also say that $M$ *computes* $f$.\n\nIn other words, if $(r_1,\\ldots, r_n)$ is in the domain of $f$, then we\nhave a halting computation\n\n  -------\n  start\n  -------\n\n   $r_1$   $\\cdots$   $r_n$   $0$   $0$   $\\cdots$\n  ------- ---------- ------- ----- ----- ----------\n\n$$\\vdots$$\n\n  ------\n  halt\n  ------\n\n   $f(r_1,\\ldots,r_n)$   $\\cdot$   $\\cdot$   $\\cdots$\n  --------------------- --------- --------- ----------\n\nIf on the other hand $(r_1,\\ldots, r_n)$ is not in the domain of $f$,\nthen the computation of the above input never terminates.\n\nFor example, $f(r_1,r_2)=r_1+r_2$, addition of two non-negative\nintegers, is URM-computable, as is shown in .\n\nHere are two more basic examples:\n\n-   (subtraction by $1$): $f(r_1)=r_1-1$. Note that $f$ is a partial\n    function that is not total, because $f(0)$ is not defined. A URM\n    that computes $f$ is the following:\n    $$M = J(1,4,1),S(2),J(1,2,6),S(3),J(1,1,2),T(3,1)$$ First, $M$\n    compares the $r_1$ with $r_4:=0$. If they are the same, it loops\n    indefinitely. Otherwise, $M$ increments $r_2$ by $1$, and then\n    compares $r_1$ with $r_2$. If they are the same, then $M$ transfers\n    $r_3:=0$ in register $3$ to $r_1$ in register $1$. Otherwise, it\n    increments $r_3$ by $1$ and loops back to the second instruction.\n    The computation continues until $r_1=r_2$, and when this happens,\n    $r_1$ is set to be $r_3$.\n\n-   (monus operation): $f(r_1)=r_1 \\dot{-} 1$. This is like the last\n    example, except $f(0):=0$. All we have to do is to modify the URM\n    above: $$M = J(1,4,6),S(2),J(1,2,6),S(3),J(1,1,2),T(3,1)$$ so the\n    first instruction jumps to the last instruction when $r_1=r_4$,\n    instead of looping.\n\n-   (parity checking): $f(r_1)=1$ if $r_1$ is odd, and $f(r_1)=0$\n    otherwise. In other words, $f(r_1)$ is the remainder of the division\n    of $r_1$ by $2$. A URM that computes $f$ is the following:\n    $$\\begin{aligned}\n    M &=& J(1,2,14),T(1,2),S(2),S(3),S(3),J(1,3,9),J(2,3,11),J(1,1,4),\\\\\n    && Z(1),J(1,1,14),Z(1),S(1),J(1,1,14)\\end{aligned}$$ Basically, with\n    input $r_1:=m$, $M$ first sets $r_2:=m+1$. Then by incrementing\n    $r_3$ by $2$, $M$ tests whether $r_1=r_3$ or $r_2=r_3$. If the\n    former, then $M$ sets $r_1:=0$, otherwise $r_1$ is set to $1$. The\n    computation stops when the program jumps to the non-existent\n    instruction $14$.\n\n**Remarks**.\n\n-   For any URM $M$ and any positive integer $n$, $M$ computes a unique\n    $n$-ary (partial) function $f$. This can be simply done as follows:\n    take the contents $r$ of the first $n$ registers of the tape as\n    input, and run $M$. Define a partial function\n    $f: \\mathbb{N}^n \\to \\mathbb{N}$ so that\n    $r\\in \\operatorname{dom}(f)$ iff $M(r)\\downarrow$, and when this is\n    the case, set $f(r)$ to be the integer such that\n    $M(r)\\downarrow \\! f(r)$.\n\n    **Examples**.\n\n    -   $T(5,2)$ computes, for any $n>0$, the $n$-ary function\n        $f(x_1,\\ldots, x_n)=x_1$.\n\n    -   $T(5,1)$ computes $f(x_1,\\ldots,x_n)=0$ for any $0<n<5$, and\n        $g(x_1,\\ldots,x_n)=x_5$ for any $n\\ge 5$.\n\n    -   $J(1,1,1)$ computes the empty function $\\varnothing$ for all\n        $n\\ge 0$.\n\n-   More generally, a partial function $f:\\mathbb{N}^n \\to \\mathbb{N}^m$\n    is said to be URM-computable iff there is a URM $M$ such that\n    $M(r_1,\\ldots,r_n)\\!\\downarrow$, and the $i$-th coordinate of\n    $f(r_1,\\ldots, r_n)$ is the content of the $i$-th register,\n    $i\\in \\lbrace 1,\\ldots, m\\rbrace$, precisely when\n    $(r_1,\\ldots,r_n)\\in \\operatorname{dom}(f)$.\n\n    The function $f$ above can be expressed as $(g_1,\\ldots, g_m)$,\n    where each $g_i: \\mathbb{N}^n \\to \\mathbb{N}$. Then it is not hard\n    to show that $f$ is URM-computable iff each $g_i$ is URM-computable.\n\n-   One of the fundamental facts about URM computability is the\n    following: a function is URM computable iff it is Turing computable.\n    By Church\u2019s thesis, this means that URM computability is equivalent\n    to effective computability.\n\n[9]{} J. C. Shepherdson, H. E. Sturgis, [*Computability of Recursive\nFunctions*]{}. Journal Assoc. Comput. Mach. 10, 217-255, (1963). N.\nCutland, [*Computability: An Introduction to Recursive Function\nTheory*]{}. Cambridge University Press, (1980).",
  "language": "INFORMAL",
  "phrase": "Urm Computable",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/URMComputable"
    }
  ],
  "indexable": true
}