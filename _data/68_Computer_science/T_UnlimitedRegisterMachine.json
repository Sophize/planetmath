{
  "alternatePhrases": [
    "URM"
  ],
  "definition": "### Informal Description {#informal-description .unnumbered}\n\nAn *unlimited register machine*, or *URM* for short, is a mathematical\nabstraction of a very primitive computer, which consists of a tape,\nwhich is left-ended, and stretches indefinitely to the right (hence the\nword \u201cunlimited\u201d). The tape is divided into squares called registers, as\nillustrated by the diagram below\n\n   $r_1$   $r_2$   $r_3$   $r_4$   $r_5$   $r_6$   $r_7$   $\\cdots$\n  ------- ------- ------- ------- ------- ------- ------- ----------\n\nEach register can store a single non-negative integer. The integer in\nthe register is called the content of the register. In the diagram\nabove, the content of the $i$-th register is $r_i$. The function of the\ntape is storage, such as inputs and outputs.\n\nThe core of a URM is its program, which is a finite sequence of\ninstructions (to be described below). The program of a URM is\nresponsible for carrying out computations. When a program is run, the\ncontents of the registers may change on the tape. The execution of the\nprogram may or may not end.\n\nThe pre-defined instructions that make up the program of a URM come in\nfour basic types:\n\n1.  zero operation $Z(n)$, which changes the content of register $n$ to\n    $0$;\n\n2.  successor operation $S(n)$, which increases the content of register\n    $n$ by $1$;\n\n3.  transfer operation $T(m,n)$, which writes (or transfers) the content\n    of register $m$ to that of register $n$;\n\n4.  jump operation $J(m,n,p)$, which, when encountered in a program,\n    \u201cjumps\u201d to the $p$-th instruction whenever the contents of registers\n    $m$ and $n$ are the same.\n\nWhereas the first three types of instructions alter the contents of the\ntape, the last type alters the flow of the program. Therefore, the three\ntypes are generally called *arithmetical instructions*, while the last\nis known as a *control instruction*.\n\n### Formal Description {#formal-description .unnumbered}\n\nBased on the information description above, we can write down precisely\nwhat a URM is.\n\nFirst, the contents of the tape is just an infinite sequence of\nnon-negative integers $r_1, r_2, \\ldots$. Let $\\mathcal{R}$ be the set\nof tape contents (sequences just described).\n\n**Definition**. A *configuration* is a pair $(r,i)$ where\n$r\\in \\mathcal{R}$, and $i\\in \\mathbb{N}$. The set of all configurations\nis denoted by $\\mathcal{C}$.\n\nNext, we define the four types of instructions, the first three of which\nare arithmetical, and the last one is a control.\n\n**Definition**. Let $m,n,p$ be arbitrary positive integers. An\n*instruction* $I$ is a function on $\\mathcal{C}$, and is any of the four\nfollowing types:\n\n1.  $Z(n)(r,i):=(r',i+1)$, where $$r'_k:= \\left\\{\n    \\begin{array}{ll}\n    0 & \\textrm{if }k = n, \\\\\n    r_k & \\textrm{otherwise.}\n    \\end{array}\n    \\right.$$\n\n2.  $S(n)(r,i):=(r',i+1)$, where $$r'_k:= \\left\\{\n    \\begin{array}{ll}\n    r_n + 1 & \\textrm{if }k = n, \\\\\n    r_k & \\textrm{otherwise.}\n    \\end{array}\n    \\right.$$\n\n3.  $T(m,n)(r,i):=(r',i+1)$, where $$r'_k:= \\left\\{\n    \\begin{array}{ll}\n    r_m & \\textrm{if }k = n, \\\\\n    r_k & \\textrm{otherwise.}\n    \\end{array}\n    \\right.$$\n\n4.  $J(m,n,p)(r,i):=(r,j)$, where $$j := \\left\\{\n    \\begin{array}{ll}\n    p & \\textrm{if }r_m = r_n, \\\\\n    i+1 & \\textrm{otherwise.}\n    \\end{array}\n    \\right.$$\n\nFor each instruction $I$, a number $R(I)$ may be associated:\n$R(Z_n)=R(S_n):=n$, and $R(T(m,n))=R(J(m,n,p)):=\\max(m,n)$.\n\n**Definition**. Given an instruction $I$, a *computation step* of $I$ is\na pair of configurations $(c_1,c_2)$ such that $c_2=I(c_1)$. $c_1,c_2$\nare called the *input* and *output configurations* of $I$\n\nA *computation sequence* is just a sequence of computation steps\n$c_1, c_2, \\ldots$ such that for each $i=1,2,\\ldots$, there is some\ninstruction $I$ (dependent on $i$) such that $c_{i+1}=I(c_i)$.\n\nOne often writes $c_1\\Longrightarrow c_2$ to denote a computation step,\nand\n$c_1 \\Longrightarrow c_2 \\Longrightarrow \\cdots \\Longrightarrow c_k \\Longrightarrow \\cdots $\nto denote a computation sequence.\n\n**Definition**. An *unlimited register machine* $M$ is a finite sequence\nof instructions $I_1, I_2, \\ldots, I_q$ (where each instruction is a\nfunction from one of the four types above). The *program* of $M$ is also\nidentified with the sequence of instructions.\n\nIn other words, a URM is just a list of instructions. What sets a URM\napart from other computing machines is in the types of instructions\nused, as well as how computations are done based on the instructions.\n\n**Definition**. Suppose $M$ is a URM, and $r \\in \\mathcal{R}$. A\n*computation* of $r$ by $M$ is a computation sequence\n$c_1 \\Longrightarrow c_2 \\Longrightarrow \\cdots \\Longrightarrow c_k \\Longrightarrow \\cdots $\nsuch that\n\n1.  $c_1=(r,1)$, and $c_2=I_1(c_1)$, and\n\n2.  if $c_k=(s,j)$, then $c_{k+1}=I_j(c_k)$.\n\nThe computation is deterministic in that the computation starts with a\nfixed initial configuration, and each computation step determines the\nnext computation step. We denote $M(r)$ the computation of $r$ by $M$.\n\nSince $M(r)$ is a sequence of computation steps, it is either a finite\nsequence or an infinite sequence:\n\n-   If it is finite, we say that the computation *halts*, *terminates*,\n    or that $M$ *converges* on $r$, and we write $M(r)\\!\\downarrow$.\n    This means that in the last computation step\n    $(s,j)\\Longrightarrow (t,k)$, we have $k>q$, so that the next\n    computation step is impossible, as the index of the instructions\n    only goes up to $q$.\n\n    If $a$ is the content of register $1$ in the ouptput, we also write\n    $M(r)\\!\\downarrow a$, and we say that $M$ *converges* (on $r$) to\n    $a$\n\n-   Otherwise, we say that the computation *runs forever*,\n    *non-terminating*, or that $M$ *diverges* on $r$, and is denoted by\n    $M(r)\\!\\uparrow$.\n\nGiven a URM $M$, one can define two numbers that are input independent:\n\n**Definition**. $|M|$ is the number of instructions in the program of\n$M$, and\n$$\\rho(M):=\\max \\lbrace R(I_k) \\mid I_k \\mbox{ is an instruction of }M \\rbrace.$$\nIn other words, $\\rho(M)$ is the largest register that may be affected\nby any computation of $M$.\n\n**Remark**. Unlimited register machines were introduced by Shepherdson\nand Sturgis in 1963. In their paper, the transfer instruction was not\nused (in fact, it is not hard to see that the transfer instruction is\nunnecessary in the current definition, as it can be \u201csimulated\u201d by a\nprogram consisting of the other instructions), and the jump instruction\nhad a different form. But the basic setup is the same, having a tape of\nconsisting of infinite squares or registers. It can be shown that URMs\nare equivalent to Turing machines in terms of their computing power.\nHowever, URMs are easier to work with, as there is an unlimited supply\nof integers rather than a finite set of symbols, and going from cell to\nthe next can be done by a single instruction, rather than a series of\nmoves.\n\n[9]{} J. C. Shepherdson, H. E. Sturgis, [*Computability of Recursive\nFunctions*]{}. Journal Assoc. Comput. Mach. 10, 217-255, (1963). N.\nCutland, [*Computability: An Introduction to Recursive Function\nTheory*]{}. Cambridge University Press, (1980).",
  "language": "INFORMAL",
  "phrase": "Unlimited Register Machine",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/UnlimitedRegisterMachine"
    }
  ],
  "indexable": true
}