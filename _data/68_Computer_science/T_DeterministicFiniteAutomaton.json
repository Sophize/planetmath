{
  "alternatePhrases": [
    "dfa",
    "finite state machine",
    "fsm"
  ],
  "definition": "A *deterministic finite automaton* (or DFA) is a deterministic automaton\nwith a finite input alphabet and a finite number of states. It can be\nformally defined as a 5-tuple $(S, \\Sigma, \\delta, q_0, F)$, where\n\n-   $S$ is a non-empty finite set of *states*,\n\n-   $\\Sigma$ is the alphabet (defining what set of input strings the\n    automaton operates on),\n\n-   $\\delta : S\\times\\Sigma\\rightarrow S$ is the *transition function*,\n\n-   $q_0 \\in S$ is the starting state, and\n\n-   $F \\subseteq S$ is a set of final (or accepting states).\n\nA DFA works exactly like a general automaton: operation begins at $q_0$,\nand movement from state to state is governed by the transition function\n$\\delta$. A word is accepted exactly when a final state is reached upon\nreading the last (rightmost) symbol of the word.\n\nDFAs represent regular languages, and can be used to test whether any\nstring in $\\Sigma^*$ is in the language it represents. Consider the\nfollowing regular language over the alphabet\n$\\Sigma := \\left\\{ \\verb.a., \\verb.b. \\right\\}$ (represented by the\nregular expression `aa*b`):\n\n$$\\begin{aligned}\n\\verb.<.S\\verb.>. & \\verb.::=. & \\verb=a=\\,A \\\\\n\\verb.<.A\\verb.>. & \\verb.::=. & b\\,\\verb.|.\\,\\verb=a=\\,A \\\\\\end{aligned}$$\n\nThis language can be represented by the DFA with the following state\ndiagram:\n\n$$\\UseComputerModernTips\n\\xymatrix {\n    \\ar[r] &\n        *+[o][F-]{0} \\ar[r]_a \\ar[rd]_b &\n        *+[o][F-]{1} \\ar@(r,u)[]_a \\ar[r]_b &\n        *++[o][F=]{2} \\ar[dl]^{a,b}\n    \\\\\n        &&\n        *+[o][F-]{3} \\ar@(r,d)[]^{a,b}\n}$$\n\nThe vertex 0 is the initial state $q_0$, and the vertex 2 is the only\nstate in $F$. Note that for every vertex there is an edge leading away\nfrom it with a label for each symbol in $\\Sigma$. This is a requirement\nof DFAs, which guarantees that operation is well-defined for any finite\nstring.\n\nIf given the string `aaab` as input, operation of the DFA above is as\nfollows. The first `a` is removed from the input string, so the edge\nfrom 0 to 1 is followed. The resulting input string is `aab`. For each\nof the next two `a`s, the edge is followed from 1 to itself. Finally,\n`b` is read from the input string and the edge from 1 to 2 is followed.\nSince the input string is now $\\lambda$, the operation of the DFA halts.\nSince it has halted in the accepting state 2, the string `aaab` is\naccepted as a sentence in the regular language implemented by this DFA.\n\nNow let us trace operation on the string `aaaba`. Execution is as above,\nuntil state 2 is reached with `a` remaining in the input string. The\nedge from 2 to 3 is then followed and the operation of the DFA halts.\nSince 3 is not an accepting state for this DFA, `aaaba` is *not*\naccepted.\n\n**Remarks**.\n\n-   A DFA can be modified to include\n    *$\\epsilon$-transitions*[EpsilonTransitions]{}. But the resulting\n    DFA can be simulated by another DFA (without any epsilon\n    transitions).\n\n-   Although the operation of a DFA is much easier to compute than that\n    of a non-deterministic automaton, it is non-trivial to directly\n    generate a DFA from a regular grammar. It is much easier to generate\n    a non-deterministic finite automaton from the regular grammar, and\n    then *transform* the non-deterministic finite automaton into a DFA.",
  "language": "INFORMAL",
  "phrase": "Deterministic Finite Automaton",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/DeterministicFiniteAutomaton"
    }
  ],
  "indexable": true
}