{
  "alternatePhrases": [
    "effective procedure",
    "Matiyasevich's theorem"
  ],
  "definition": "Intuitive Introduction {#intuitive-introduction .unnumbered}\n----------------------\n\nAn algorithm, generally speaking, is a collection of instructions that\nprovides a step-by-step procedure on how to complete a particular task.\nExamples of algorithms in real life range from a simple recipe on how to\nbake a fruit pie, to an owner\u2019s manual of a newly purchased television,\nto the complicated process of producing an automobile in an assembly\nline.\n\nIn mathematics, an algorithm can be thought of, in a narrower sense, as\na set of mathematical instructions on how to complete a mathematical\ntask. For example, if we were interested in determining that, given an\nintegral quadratic equation\n$$ax^2+bx+c=0,\\mbox{ where }a,b,c\\in\\mathbb{Z}\\mbox{ and }a\\ne 0$$ if an\nintegral solution for $x$ exists, a possible algorithm for solving this\nproblem would be\n\n1.  first of all, check if $b^2-4ac$ is some square $d^2$ with\n    $d\\in \\mathbb{Z}$.\n\n2.  If not, then no integral solutions exist.\n\n3.  If so, check next if $2a$ divides either $-b+d$ or $-b-d$.\n\n4.  If not, then no integral solutions exist.\n\n5.  If so, then yes, an integral solution exists.\n\nAlgorithms abound in mathematics, from the familiar adding and\nmultiplying two integers, to solving a system of linear equations, to\nprocesses much more complicated, such as determining if two groups are\nisomorphic.\n\nTo understand algorithms a little better, let us see what all of the\nalgorithms mentioned so far have in common. Three essential features of\na typical algorithm that come to mind are\n\n-   the set of instructions must be *finite*, and\n\n-   each instruction must be precise with no ambiguity.\n\n-   the algorithm must be re-usable.\n\nFeature (a) says that, in order to be able to solve a problem using an\nalgorithm, there must not be an infinite list of instructions, lest we\nwill never be able to get to a solution. This is different from saying\nthat, given an input, the *actual computation* of an algorithm is\nfinite. For example, given any positive integer, one can calculate its\nsquared root. An algorithm exists to carry out this computation.\nHowever, unless the integer is a square, the actual computation will go\non indefinitely, with a more accurate approximation of the actual value\nafter each iteration. Feature (b) simply means that, given an input, if\nwe were to give the corresponding algorithm to someone to carry out the\ncomputations to arrive at an output, the person (or machine) carrying\nout the steps should have no trouble in doing so. For example, if we\nwere to give the algorithm above to a math student, he/she should have\nno trouble in following each of the instructions. However, if we were to\nhand the algorithm to someone who has never studied math before, we are\nin trouble. What does it mean for an integer to be a square? What does\nit mean for a number to divide another number? We would have to break\ndown the instructions into even simpler ones, until there is no\nambiguity in the solver\u2019s mind what they are. Finally, feature (c) means\nthat if a particular input is given, then it does not matter when the\ncomputations are carried out, and we will always get the same output.\nFor example, if $x^2-4x+3$ has integral solutions, as determined by\nalgorithm $A$, then we would not expect to find that $x^2-4x+3$ has *no*\nintegral solutions two days later again using $A$.\n\n**Remark**. The last feature is sometimes relaxed so that \u201cre-usable\u201d\nmeans that the output is *as expected*. This means that an algorithm may\ninclude an instruction to, say, toss a coin, or to use a random number\ngenerator, in order to move forward with a computation. A common example\nof an algorithm involving a random device is the algorithm to draw a\nsimple random sample from a given population. One computation results in\na sample that is almost guaranteed to be different from the sample\nproduced by a later computation. Nevertheless, if a certain sample size\nis asked for, that sample size will be constant from one computation to\nthe next.\n\nAlgorithms and Computations {#algorithms-and-computations .unnumbered}\n---------------------------\n\nClosely associated with the notion of an algorithm is the notion of\ncomputation, mentioned earlier but not formally introduced. Given an\ninput $x$, *computation* is the actual execution of the given $x$ using\ninstructions in some algorithm $A$. Each step in the computation is a\n*computation step*. Depending on the input, the computation either\nterminates or halts, after a finite number of computation steps, or goes\non indefinitely. When the computation terminates, an output $y$ is\nproduced, and we say that the computation is *effective*, or that the\noutput $y$ can be *effectively computed* (with respect to the algorithm\n$A$). A function $f$ is said to be $A$-*computable* if, for each input\n$x$ in the domain of $f$, the output $f(x)$ can be effectively computed.\nFurthermore, $f$ is *effectively computable* if there is an algorithm\n$A$ such that $f$ is $A$-computable. An *effective procedure* is another\nway of calling an algorithm. For example, addition of two integer is\neffectively computable. Given two integers $a,b$, there is an algorithm\n$A$ such that, when a computation is carried out using $A$, the result\n$a+b$ will be produced.\n\nAre there any functions that are not effectively computable? More\ngenerally, are there (mathematical) problems which can not be solved\nusing algorithms? This is basically equivalent to asking: are there\nfunctions that are not effectively computable? Intuition tells us that\nthere are. For example, if we want to generalize the procedure of\ndetermining the existence of integral solutions to a quadratic equations\nto a general polynomial equations of degree $n$, we would most likely\nnot succeed. In fact, this is a special case of a more general problem\nknown as Hilbert\u2019s 10th Problem:\n\n> given a diophantine equation, can one determine if it has any integral\n> solutions using an algorithm?\n\nHow does one prove this rigorously? Of course, to answer such a\nquestion, one needs to treat an \u201calgorithm\u201d itself as a mathematical\nobject, since the informal heuristic description above is inadequate.\n\nAbstractions of Algorithms {#abstractions-of-algorithms .unnumbered}\n--------------------------\n\nDuring the early and middle part of the 1900\u2019s, various proposals of\nwhat an algorithm is were put forth. These include include:\n\nT\n\n:   Turing machine (Turing)\n\nR\n\n:   partial recursive functions (Kleene)\n\nL\n\n:   (Church)\n\nM\n\n:   Markov algorithm (Markov)\n\nP\n\n:   Post system (Post)\n\nS\n\n:   semi-Thue system (Thue)\n\nU\n\n:   unlimited register machine, or URM (Shepherdson and Sturgis)\n\nSome, like [**T**]{} and [**U**]{}, have more of a resemblance of the\nintuitive notion of an algorithm described earlier, while some, like\n[**M**]{}, [**P**]{} and [**S**]{}, are based on the realization that\ninput and instructions are nothing but strings of symbols, and\ncomputation is nothing more than transforming one string into another\nstring. Nevertheless, in each of the above proposals, it is possible to\nrigorously define the notion of \u201ccomputability\u201d informally described\nearlier. As it turns out, the class of computable functions according to\neach of the proposals turns out to be identical! In other words, Turing\ncomputability is equivalent to Markov computability, etc...\n\n**Remark**. Although it was generally suspected that Hilbert\u2019s 10th\nProblem was false, it was not until 1970, that Yuri Matiyasevi\u010d proved\nthe 10th Problem in the negative. This fact is now known as\nMatiyasevi\u010d\u2019s theorem.",
  "language": "INFORMAL",
  "phrase": "Algorithm",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/Algorithm"
    }
  ],
  "indexable": true
}