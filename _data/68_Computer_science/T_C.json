{
  "alternatePhrases": [
    "C with Classes"
  ],
  "definition": "[*++*]{} is a compiled multi-paradigm programming language based on C\nthat supports procedural, object-oriented and generic programming\nparadigms. It was developed by Bjarne Stroustrup at Bell Labs in 1983,\nthe same year that the ANSI C standard was ratified. Working in tandem,\nthe ANSI and ISO ratified standard C++ in 1998.\n\nThe following C++ program takes two integers as inputs and outputs their\ngreatest common divisor using Euclid\u2019s algorithm.\n\n    #include <iostream> \n\n    template<typename T>\n    T gcd(T x, T y) {\n      while ( y != 0 ) {\n        T z = x % y;\n        x = y;\n        y = z;\n      }\n      return x;\n    }\n\n    int main() { \n      int inputX, inputY; \n\n      std::cout << \"Please enter x: \";\n      std::cin >> inputX; \n      std::cout << \"Please enter y: \";\n      std::cin >> inputY; \n\n      std::cout << \"The GCD of \" << inputX \n                << \" and \" << inputY \n                << \" is \" << gcd(inputX,inputY) << std::endl; \n\n      return 0;\n    }\n\nThis program works pretty much the same as . Instead of C\u2019s standard I/O\nlibrary, the program uses C++\u2019s `iostream` library. A substantial\ndifference between the two programs is that the C++ version of `gcd`\nfunction is more general: not only can it work with integers of type\n`int`, the same code can work[^1] with *any* type that has division with\nremainder defined. The division with remainder corresponds to the\noperator `%` in C++.\n\nNote that the algorithm, for integers, may return negative numbers for\nthe greatest common divisor, if an input contains a negative. The\nalgorithm is still correct, however, if the \u201cgreatest common divisor\u201d is\nsuitably defined, as in modern abstract algebra, to be unique only up to\nunits in a ring. See [@Stepanov] \u2014 which is where the present example\ncomes from \u2014 for an interesting discussion around this point.\n\nWe could define another GCD function with the same name but that took\nthree integers as input and returned the GCD of the trio. Or we could\ncreate our own complex integer object and then write a GCD function with\nthe same name that took complex integers as input. Furthermore, we could\ndefine the operators so as to enable a programmer to write things like\n`w = u + v;` with complex integers rather something like\n`w.setVal(complexAddition(u, v));`. The programmer\u2019s imagination is the\nlimit: the addition operator for a set object could be defined to either\nadd up each element in one set to an element in a second set, or to\nperform a union of the two sets. Even in our simple GCD example, C++\u2019s\n`iostream` library has overloaded the bitwise operators to perform\nconcatenation.\n\n[XXXXX]{} Alexander Stepanov. : C++ Programming with the Standard\nTemplate Library, second ed. Addison-Wesley, 2001.\n\n[^1]: Moreover, unlike most other object-oriented languages, this\n    abtraction imposes absolutely no performance penalty at run-time.",
  "language": "INFORMAL",
  "phrase": "C++",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/C"
    }
  ],
  "indexable": true
}