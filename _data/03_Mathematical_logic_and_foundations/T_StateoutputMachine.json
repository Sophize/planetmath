{
  "alternatePhrases": [],
  "definition": "### Definition {#definition .unnumbered}\n\nA *state-output machine* can be thought of as state machine with an\noutput feature: when a word is fed into the machine as input, the\nmachine goes through a series of internal \u201cstates\u201d where certain\ntranslations take place, and finally a set of words are produced as\noutputs.\n\nFormally, a *state-output machine* $M$ is a five-tuple\n$(S,\\Sigma,\\Delta, \\delta,\\lambda)$ where\n\n1.  $(S,\\Sigma,\\delta)$ is a state machine (or semiautomaton),\n\n2.  $\\Delta$ is a non-empty set whose elements are called *output\n    symbols*, and\n\n3.  $\\lambda: S\\times \\Sigma \\to P(\\Delta)$ is a function called the\n    *output function*.\n\nThe sets $S,\\Sigma,$ and $\\Delta$ are generally considered to be finite.\nIn the literature, a finite state-output machine is also known as\n*transducer*.\n\nNote that there is no restrictions on the sizes of $\\lambda(s,a)$ and\n$\\delta(s,a)$. Various classifications based on the cardinalities of\n$\\lambda(s,a)$ and $\\delta(s,a)$ are possible: for all\n$(s,a)\\in S\\times \\Sigma$,\n\n-   $M$ is *complete* if $|\\lambda(s,a)|\\ge 1$ and $|\\delta(s,a)|\\ge 1$;\n    otherwise, it is *incomplete*;\n\n-   $M$ is *sequential* if $|\\lambda(s,a)|\\le 1$ and\n    $|\\delta(s,a)|\\le 1$.\n\nBoth $\\delta$ and $\\lambda$ can be extended so its first component takes\non a set $T$ of states:\n$$\\delta(T,a):=\\bigcup \\lbrace \\delta(t,a)\\mid t\\in T\\rbrace \\qquad \\mbox{and} \\qquad \\lambda(T,a):=\\bigcup \\lbrace \\lambda(t,a)\\mid t\\in T\\rbrace.$$\nNote that $\\delta(\\varnothing,a)=\\lambda(\\varnothing,a)=\\varnothing$ for\nany input symbol $a\\in \\Sigma$.\n\n### Words as Input {#words-as-input .unnumbered}\n\nThe transition and the output functions of a state-output machine $M$\nare defined to work only over individual symbols in $\\Sigma$ as inputs.\nHowever, finite strings of symbols over $\\Sigma$, or words, are usually\nfed to the $M$, instead of individual symbols. Therefore, we would like\nmodify $\\delta$ and $\\lambda$ in order to handle finite strings as well.\n\nExtending $\\delta$.\n\n:   When a machine $M$ receives an input word $u$, it reads $u$ one\n    symbol at a time, starting from the left, until the last symbol is\n    read. After reading each symbol, the machine goes into a next state,\n    dictated by the transition function $\\delta$. If $M$ is at state $s$\n    upon receiving $u$, we define a next state as a state that $M$\n    enters after reading the last symbol of $u$.\n\n    Based on the above discussion, we are ready to extend $\\delta$ so it\n    takes on words over $\\Sigma$. This is done inductively:\n\n    -   $\\delta'(s,\\epsilon):=\\lbrace s\\rbrace$, where $\\epsilon$ is the\n        empty word, and $s$ is any state;\n\n    -   $\\delta'(s, u a):= \\delta(\\delta'(s,u),a)$, where $a\\in \\Sigma$\n        and $u\\in \\Sigma^*$.\n\n    It is easy to see that $\\delta'(s, uv)= \\delta'(\\delta'(s,u),v)$.\n\nExtending $\\lambda$.\n\n:   There are in general two ways to view output(s) for a given input\n    word:\n\n    1.  The first, more common, approach, is to view outputs as being\n        produced after the last symbol of the input word is processed:\n\n        -   $\\lambda'(s, \\epsilon):= \\varnothing$, and\n\n        -   $\\lambda'(s, u a):= \\lambda(\\delta'(s,u),a)$, where $u$ is a\n            word over $\\Sigma$.\n\n        If $\\lambda$ does not depend on input symbols, say\n        $\\lambda(s,a)=\\beta(s)$ for all $(s,a)\\in S\\times \\Sigma$, the\n        above definition may be modified so that non-empty output(s) may\n        be produced by the empty input word $\\epsilon$:\n\n        -   $\\lambda'(s,u):= \\beta(\\delta'(s,u))$, where $u$ is any word\n            over $\\Sigma$.\n\n        It is easy to see that $\\lambda(s,\\epsilon)=\\beta(s)$. Note that\n        this is not a true extension of the original output function,\n        because the new output function now depends on inputs.\n\n    2.  Alternatively, outputs may be produced each time a transition\n        occurs. In other words, outputs are words over $\\Delta$. Thus,\n        outputs are inductively as follows:\n\n        -   $\\lambda'(s, \\epsilon):= \\lbrace \\epsilon \\rbrace$, where\n            $\\epsilon$ is the empty word, and\n\n        -   $\\lambda'(s, u a):= \\lambda'(s,u) \\lambda(\\delta'(s,u),a)$,\n            where $a\\in \\Sigma$ and $u\\in \\Sigma^*$.\n\nWhen there is no confusion, we may continue to denote $\\lambda$ and\n$\\delta$ as the extensions of the original next-state and output\nfunctions.\n\nGiven $M$, define an *input configuration* as a pair $(s,u)$ for some\n$s\\in S$ and $u\\in \\Sigma^*$, and an *output configuration* as a pair\n$(t,v)$ for some $t\\in S$ and $v\\in \\Delta^*$. The set of output\nconfigurations for a given input configuration $(s,u)$ is given by\n$\\delta(s,u)\\times \\lambda(s,u)$.\n\n### Generator and Acceptor {#generator-and-acceptor .unnumbered}\n\nOne may treat a state-output machine\n$M=(S,\\Sigma,\\Delta, \\delta,\\lambda)$ as either a *language generator*\nor a *language acceptor*. The idea is that a set of states and a set of\nwords need to be specified as initial conditions, so that words can\neither be generated or accepted from these initial conditions. The way\nthis works is as follows:\n\n$M$ as a generator.\n\n:   Fix a non-empty set $I\\subseteq S$ of *starting states*, and a\n    non-empty set $G\\subseteq \\Sigma^*$. The triple $(M,I,G)$ is called\n    a *generator*. A string $b\\in \\Delta^*$ is *generated by* $(M,I,G)$\n    if $b\\in \\lambda(s,a)$ for some $(s,a)\\in I\\times G$. The set of all\n    strings generated by $(M,I,G)$ is also denoted by $L(M,I,G)$.\n\n    A typical example of a generator is a Post system: a state machine\n    where the output alphabet is the input alphabet, and the set of\n    states and the state function is suppressed ($S$ may be taken as a\n    singleton).\n\n$M$ as an acceptor.\n\n:   Dually, fix a non-empty set $F\\subseteq S$ called the *final\n    states*, and a non-empty set $A\\subseteq \\Delta^*$. The triple\n    $(M,F,A)$ is called an *acceptor*. A string $a\\in \\Sigma^*$ is said\n    to be accepted by $(M,F,A)$ if $\\delta(s,a)\\in F$ and\n    $\\lambda(s,a)\\in A$ for some state $s\\in S$. The set of all strings\n    accepted by $(M,F,A)$ is denoted by $L(M,F,A)$.\n\n    A typical example of an acceptor is an automaton: a state machine\n    where the output alphabet and the output function are not essential\n    ($\\Delta^*$ may be taken as a singleton).\n\n**Remark**. Observe that the functions $\\delta$ and $\\lambda$ can be\ncombined to form a single function\n$\\tau: S\\times \\Sigma \\to P(S)\\times P(\\Delta)$ such that\n$\\tau=(\\delta,\\lambda)$. One can generalize this so that $\\tau$ is a\nfunction from $S\\times \\Sigma$ to $P(S\\times \\Delta)$, or more\ngenerally, to $P(S\\times \\Delta^*)$. The resulting construct is commonly\nknown as a *generalized sequential machine*.\n\n[8]{} S. Ginsburg, [*An Introduction to Mathematical Machine Theory*]{},\nAddision-Wesley, (1962). M. Arbib, *Algebraic Theory of Machines,\nLanguages, and Semigroups*, Academic Press, (1968). J. Hartmanis, R.E.\nStearns, *Algebraic Structure Theory of Sequential Machines*,\nPrentice-Hall, (1966).",
  "language": "INFORMAL",
  "phrase": "State-Output Machine",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/StateoutputMachine"
    }
  ],
  "indexable": true
}