{
  "alternatePhrases": [
    "minimization operator",
    "minimization-operator",
    "search operator",
    "search-operator"
  ],
  "definition": "$\\mu$ on predicates {#mu-on-predicates .unnumbered}\n-------------------\n\nLet a property on non-negative integers be given. Informally, the\n$\\mu$-operator looks for the smallest number satisfying the given\nproperty. The $\\mu$-operator is also known as the (unbounded)\nminimization operator or the (unbounded) search operator. Formally,\n\n**Definition**. Let $\\Phi(\\boldsymbol{x},y)$ be an $(m+1)$-ary predicate\n(property) over $\\mathbb{N}$, the set of natural numbers ($0$ included\nhere), with $m$ a non-negative integer ($\\boldsymbol{x}$ is $m$-ary).\nDefine\n$$A_{\\Phi}(\\boldsymbol{x}):=\\lbrace y \\in \\mathbb{N} \\mid \\Phi(\\boldsymbol{x},y) \\rbrace,$$\nThe *$\\mu$-operator* on $\\Phi$ is given by\n$$\\mu y \\Phi(\\boldsymbol{x},y) := \\left\\{\n\\begin{array}{ll}\n\\min A_{\\Phi}(\\boldsymbol{x}) & \\textrm{if } A_{\\Phi}(\\boldsymbol{x})\\ne \\varnothing, \\\\\n\\textrm{undefined} & \\textrm{otherwise.}\n\\end{array}\n\\right.$$ The notation $\\mu y \\Phi(\\boldsymbol{x},y)$ reads \u201cthe\nsmallest $y$ such that $\\Phi(\\boldsymbol{x},y)$ is satisfied\u201d. Note that\n$y$ is used both as a variable and a number that the variable $y$\nrepresents.\n\nNote that $\\mu y \\Phi(\\boldsymbol{x},y)$ is a partial function on\n$\\boldsymbol{x}$ ($y$ is a bounded variable). In other words, the\n$\\mu$-operator is a function that takes an $m+1$-ary predicate to an\n$m$-ary partial function. When $m=0$, $\\mu$ is either an integer, or\n$\\varnothing$.\n\nFor example, suppose $\\Phi(x,y)$ is the property $(x-y)(x+y) \\ge 10$.\nThen $\\mu y \\Phi(x,y) = 0$ iff $x\\ge 4$, and undefined otherwise.\n\nThe reason why the $\\mu$-operator is called the search operator comes\nfrom recursive function theory. The search for the smallest $y$ such\nthat $\\Phi(\\boldsymbol{x},y)$ begins with testing for\n$\\Phi(\\boldsymbol{x},0)$. If the test fails ($\\Phi(\\boldsymbol{x},0)$ is\nfalse), then testing for\n$\\Phi(\\boldsymbol{x},1), \\Phi(\\boldsymbol{x},2), \\Phi(\\boldsymbol{x},3), \\cdots$\nare successively performed. The testing stops when a $y$ with\n$\\Phi(\\boldsymbol{x},y)$ is found. This $y$ is also the smallest $y$\nsatisfying $\\Phi$. Nevertheless, the testing can conceivably go on\nindefinitely, hence the name *unbounded*. There is also a bounded\nversion of $\\mu$-operation:\n\n**Definition**. Let $\\Phi(\\boldsymbol{x},y)$ be given as above. Define\n$$A_{\\Phi}(\\boldsymbol{x},y):=\\lbrace z \\in \\mathbb{N} \\mid \\Phi(\\boldsymbol{x},z)\\mbox{ and }z\\le y \\rbrace.$$\nThe *bounded $\\mu$-operator* on $\\Phi$ is given by\n$$\\mu z\\le y \\Phi(\\boldsymbol{x},z) := \\left\\{\n\\begin{array}{ll}\n\\min A_{\\Phi}(\\boldsymbol{x},y) & \\textrm{if } A_{\\Phi}(\\boldsymbol{x},y)\\ne \\varnothing, \\\\\ny+1 & \\textrm{otherwise.}\n\\end{array}\n\\right.$$ Thus the bounded $\\mu$-operator takes an $(m+1)$-ary predicate\n(on $(\\boldsymbol{x},z)$, where $z$ is a free variable) to an\n$(m+1)$-ary total function (on $(\\boldsymbol{x},y)$, as $z$ is now\nbounded by $\\mu$).\n\n$\\mu$ on total functions {#mu-on-total-functions .unnumbered}\n------------------------\n\nThe $\\mu$ operator can also be defined on functions. We first discuss\nthe case of $\\mu$ on total functions.\n\n**Definition**. Given a total $(m+1)$-ary function\n$f:\\mathbb{N}^{m+1}\\to \\mathbb{N}$, define\n$$A_f(\\boldsymbol{x}):=\\lbrace y \\in \\mathbb{N} \\mid f(\\boldsymbol{x},y)=0 \\rbrace,$$\nThe *$\\mu$-operator* on $f$ is given by\n$$\\mu y f(\\boldsymbol{x},y) := \\left\\{\n\\begin{array}{ll}\n\\min A_f(\\boldsymbol{x}) & \\textrm{if } A_f(\\boldsymbol{x})\\ne \\varnothing, \\\\\n\\textrm{undefined} & \\textrm{otherwise.}\n\\end{array}\n\\right.$$\n\nThis definition is actually equivalent to the one regarding predicates,\nin the following sense: given a total function $f$ with arity $m+1$,\ndefine predicate $\\Phi_f(\\boldsymbol{x},y)$ of arity $m+1$, as\n\u201c$f(\\boldsymbol{x},y)=0$\u201d. Then\n$$\\mu y f(\\boldsymbol{x},y) = \\mu y \\Phi_f(\\boldsymbol{x},y).$$\nConversely, given an $(m+1)$-ary predicate $\\Phi(\\boldsymbol{x},y)$,\ndefine an $(m+1)$-ary function\n$f_{\\Phi}(\\boldsymbol{x},y):=1\\dot{-} \\chi_{\\Phi}(\\boldsymbol{x},y)$,\nwhere $\\chi_{\\Phi}$ is the characteristic function of $\\Phi$. Then\n$$\\mu y \\Phi(\\boldsymbol{x},y) = \\mu y f_{\\Phi}(\\boldsymbol{x},y).$$\n\nNote also that $\\mu f$ may be partial even if $f$ is total, since it is\npossible $f(\\boldsymbol{x},y)\\ne 0$ for all $y$, and the search will go\non indefinitely. For example, let $f(x,z,y)= x^2+z^2 - y^2$ if\n$x^2+z^2 \\ge y^2$, and $1$ otherwise. Clearly, $f$ is a total function.\nIt is easy to see that $\\mu y f(3,4,y) = 5$, while $\\mu y f(1,2,y)$ is\nundefined.\n\n$\\mu$ on partial functions {#mu-on-partial-functions .unnumbered}\n--------------------------\n\nThe definition of the $\\mu$-operator on total functions can be\ngeneralized to partial functions. However, in recursive functions\ntheory, an additional condition is imposed in order to make the\ngeneralization.\n\n**Definition**. Given a partial $(m+1)$-ary function\n$f:\\mathbb{N}^{m+1}\\to \\mathbb{N}$, define\n$$A_f(\\boldsymbol{x}):=\\lbrace y \\in \\mathbb{N} \\mid f(\\boldsymbol{x},y)=0 \\mbox{ and }(\\boldsymbol{x},z) \\in \\operatorname{dom}(f) \\mbox{ for all }z\\le y\\rbrace,$$\nThe *$\\mu$-operator* on $f$ is given by\n$$\\mu y f(\\boldsymbol{x},y) := \\left\\{\n\\begin{array}{ll}\n\\min A_f(\\boldsymbol{x}) & \\textrm{if } A_f(\\boldsymbol{x})\\ne \\varnothing, \\\\\n\\textrm{undefined} & \\textrm{otherwise.}\n\\end{array}\n\\right.$$\n\nThe extra condition that $f(\\boldsymbol{x},z)$ be defined for all\n$z\\le y$ is needed in order to avoid situations where testing for\n$f(\\boldsymbol{x},z)=0$ gets stuck in an infinite loop (in a Turing\nmachine or a URM) because $f(\\boldsymbol{x},z)$ is undefined, before $y$\nis ever reached for testing. If we drop this extra condition, then it is\npossible to find a partial recursive function $f$ such that $\\mu f$ is\nnot recursive.\n\n**Remarks**.\n\n-   Bounded $\\mu$-operator may also be defined on functions. In the case\n    of partial functions, the definition can be given as follows: let\n    $f(\\boldsymbol{x},y)$ be an $(m+1)$-ary partial function, with\n    $$A_f(\\boldsymbol{x},y):=\\lbrace z \\in \\mathbb{N} \\mid f(\\boldsymbol{x},z)=0, z\\le y,\\mbox{ and }(\\boldsymbol{x},t)\\in \\operatorname{dom}(f)\\mbox{ for all }t\\le z  \\rbrace,$$\n    then $$\\mu z\\le y f(\\boldsymbol{x},z) := \\left\\{\n    \\begin{array}{ll}\n    \\min A_f(\\boldsymbol{x},y) & \\textrm{if } A_f(\\boldsymbol{x},y)\\ne \\varnothing, \\\\\n    y+1 & \\textrm{if }A_f(\\boldsymbol{x},y)= \\varnothing \\mbox{ and }(\\boldsymbol{x},t) \\in \\operatorname{dom}(f) \\mbox{ for all }t\\le y \\\\\n    \\textrm{undefined} & \\textrm{otherwise.}\n    \\end{array}\n    \\right.$$\n\n-   Given the set $\\mathcal{PR}$ of primitive recursive functions, one\n    obtains the set $\\mathcal{R}$ of recursive functions by taking the\n    closure of $\\mathcal{PR}$ with respect to the application of the\n    $\\mu$-operator. Furthermore, if $f\\in \\mathcal{R}$, so is\n    $\\mu f \\in \\mathcal{R}$, and it can be shown that any recursive\n    function can be obtained from primitive recursive functions by no\n    more than one application of the $\\mu$-operator. This is known as\n    the Kleene normal form theorem.\n\n-   With respect to the bounded $\\mu$-operator, any primitive recursive\n    function (or predicate) stays primitive recursive after an\n    application of the bounded $\\mu$, and any total recursive function\n    stays total after an application of the bounded $\\mu$.",
  "language": "INFORMAL",
  "phrase": "$\\Mu$-Operator",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/muoperator"
    }
  ],
  "indexable": true
}