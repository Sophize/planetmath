{
  "language": "INFORMAL",
  "remarks": "",
  "statement": "In this entry, we give a formal proof that the Ackermann function\n$A(x,y)$, given by\n$$A(0,y)=y+1,\\qquad A(x+1,0)=A(x,1),\\qquad A(x+1,y+1)=A(x,A(x+1,y))$$ is\nboth a total function and a recursive function. Actually, the fact that\n$A$ is total is proved in . It remains to show that $A$ is recursive.\n\nRecall that the computation of $A(x,y)$, given $x,y$, can be thought of\nas an iterated operation performed on finite sequences of integers,\nstarting with $x,y$ and ending with $z=A(x,y)$ (see ). It is this\nprocess we will utilize to prove that $A$ is recursive.\n\nIn the proof below, the following notations and definitions are used to\nsimplify matters:\n\n-   if $s$ is the sequence $r_1,\\ldots, r_m$, then $E(s)$ or\n    $\\langle r_1,\\ldots, r_m\\rangle$ denote the code number of $s$ given\n    the encoding $E$;\n\n-   $\\operatorname{lh}(n)$ is the length of the sequence whose code\n    number is $n$;\n\n-   $(n)_i$ is the $i$-th number in the sequence whose code number is\n    $n$;\n\n-   $(n)_{-i}$ is the $i$-th to the last number in the sequence whose\n    code number is $n$ (so that $(n)_{-1}$ is the last number in the\n    sequence whose code number is $n$);\n\n-   $\\operatorname{red}(n)$ is the code number of the sequence obtained\n    by deleting the last number of the sequence whose code number is\n    $n$;\n\n-   $\\operatorname{ext}(n,a)$ is the code number of the sequence\n    obtained by appending $a$ to the end of the sequence whose code\n    number is $n$.\n\nIf $E$ is a primitive recursive encoding, then each of the above\nfunction is primitive recursive. For example,\n$(n)_{-i}=(n)_{\\operatorname{lh}(n)\\dot{-}i+1}$.\n\n$A$ is recursive.\n\nIn this proof, the choice of encoding $E$ is the multiplicative\nencoding, for it is convenient and, more importantly, a primitive\nrecursive encoding. Briefly,\n$$E(r_1,\\ldots, r_m)=p_1^{r_1+1}\\cdots p_m^{r_m+1},$$ where $p_i$ is the\n$i$-th prime number (so that $p_1=2$).\n\nWe know that computing $A(x,y)=z$ is basically a sequence of\ncomputations on finite sequences:\n$$x,y \\longrightarrow \\cdots \\longrightarrow z \\longrightarrow z \\longrightarrow \\cdots$$\nLet $s(x,y,i)$ denote the sequence at step $i$, then the above sequence\ncan be rewritten:\n$$s(x,y,0) \\longrightarrow s(x,y,1) \\longrightarrow \\cdots \\longrightarrow s(x,y,k) \\longrightarrow \\cdots$$\nDefine $f(x,y,i)=E(s(x,y,i))$. From this we see that\n$$g(x,y)=\\mu i [f(x,y,i)=f(x,y,i+1)].$$ is the function that computes\nthe smallest number of steps needed so that the code number becomes\nstationary. When the code number is decoded, we get the resulting value\nof $A(x,y)$: $$A(x,y)=D(f(x,y,g(x,y))),$$ where $D(m):=(m)_{-1}$,\ndecodes $m$, and returns the last number in the sequence $s$ whose code\nnumber $E(s)$ is $m$.\n\nNow the remaining task to show that $f$ is primitive recursive. First,\nnote that $$f(x,y,0) = \\langle x,y\\rangle = 2^{x+1}3^{y+1}$$ is\nprimitive recursive. Next, we want to express\n$$f(x,y,n+1)=h(f(x,y,n)),$$ where $h$ is the function that changes the\ncode number of the sequence $s(x,y,n)$ to the code number of the\nsequence $s(x,y,n+1)$. Once we obtain $h$ and show that $h$ is primitive\nrecursive, then $f$ is primitive recursive, as it is defined by\nprimitive recursion via primitive recursive functions\n$\\langle x,y\\rangle$ and $h$.\n\nTo find out what $h$ is, recall the four rules of constructing the next\nsequence from the current one givne in this . Let $n_1=E(s(x,y,k))$ and\n$n_2=E(s(x,y,k+1))$. We rewrite the four rules using the notations and\ndefinitions here:\n\n1.  if $\\operatorname{lh}(n_1)=1$, then $n_2=n_1$;\n\n2.  if $\\operatorname{lh}(n_1)>1$, and $(n_1)_{-2}=0$, then\n    $n_2=h_1(n_1)$, where\n    $$h_1(n):= \\operatorname{ext}(\\operatorname{red}^2(n),(n)_{-1}+1);$$\n\n3.  if $\\operatorname{lh}(n_1)>1$, and $(n_1)_{-2}>0$ and\n    $(n_1)_{-1}=0$, then $n_2=h_2(n_1)$, where\n    $$h_2(n):=\\operatorname{ext}(\\operatorname{ext}(\\operatorname{red}^2(n),(n)_{-2}-1),1);$$\n    or\n\n4.  if $\\operatorname{lh}(n_1)>1$, and $(n_1)_{-2}>0$ and\n    $(n_1)_{-1}>0$, then then $n_2=h_3(n_1)$, where\n    $$h_3(n):=\\operatorname{ext}(\\operatorname{ext}(\\operatorname{ext}(\\operatorname{red}^2(n),(n)_{-2}-1),(n)_{-2}),(n)_{-1}-1).$$\n\nIf we define predicates:\n\n1.  $\\Phi_0(n):=\\operatorname{lh}(n)\\le 1$,\n\n2.  $\\Phi_1(n):=\\operatorname{lh}(n)>1\\textrm{, and }(n)_{-2}=0$,\n\n3.  $\\Phi_2(n):=\\operatorname{lh}(n)>1\\textrm{, and }(n)_{-2}>0\\textrm{ and }(n)_{-1}=0$,\n\n4.  $\\Phi_3(n):=\\operatorname{lh}(n)>1\\textrm{, and }(n)_{-2}>0\\textrm{ and }(n)_{-1}>0$.\n\nThen each $\\Phi_i$ is primitive recursive, pairwise exclusive, and\n$\\Phi_0\\equiv \\neg \\Phi_1 \\wedge \\neg \\Phi_2 \\wedge \\neg \\Phi_3$. Now,\ndefine $h$ as follows: $$h(n):= \\left\\{\n\\begin{array}{ll}\n\\operatorname{id}(n) & \\textrm{if }\\Phi_0(n),\\\\\nh_1(n) & \\textrm{if }\\Phi_1(n),\\\\\nh_2(n) & \\textrm{if }\\Phi_2(n),\\\\\nh_3(n) & \\textrm{if }\\Phi_3(n).\n\\end{array}\n\\right.$$ Since $h$ is defined by cases, and each $h_i$ is primitive\nrecursive, $h$ is also primitive recursive.",
  "citations": [
    {
      "textCitation": "https://planetmath.org/AckermannFunctionIsTotalRecursive"
    }
  ],
  "indexable": true,
  "names": [
    "Ackermann function is total recursive"
  ]
}