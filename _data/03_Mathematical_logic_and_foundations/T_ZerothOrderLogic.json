{
  "alternatePhrases": [],
  "definition": "***Note.** This entry overlaps to some degree with other entries on and\n, but serves as a compact reference and a translation manual for several\ndifferent styles of notation.*\n\n***Zeroth order logic*** is a term in popular use among practitioners\nfor the common principles underlying the algebra of sets, boolean\nalgebra, boolean functions, logical connectives, monadic predicate\ncalculus, propositional calculus, and sentential logic. The term serves\nto mark a level of abstraction in which the inessential differences\namong these subjects can be subsumed under the appropriate isomorphisms.\n\nPropositional forms\n===================\n\nTable 1 lists equivalent expressions for the four functions of concrete\ntype $X \\to \\mathbb{B}$ and abstract type $\\mathbb{B} \\to \\mathbb{B}$ in\na number of different languages for zeroth order logic.\n\n> [|c|c|c|c|c|c|c|]{}\\\n> $\\mathcal{L}_1$ & $\\mathcal{L}_2$ && $\\mathcal{L}_3$ & $\\mathcal{L}_4$\n> & $\\mathcal{L}_5$ & $\\mathcal{L}_6$\\\n> & & $x =$ & 1 0 & & &\\\n> $f_{0}$ & $f_{00}$ & & 0 0 & $( )$ & false & $0$\\\n> $f_{1}$ & $f_{01}$ & & 0 1 & $(x)$ & not $x$ & $\\lnot x$\\\n> $f_{2}$ & $f_{10}$ & & 1 0 & $x$ & $x$ & $x$\\\n> $f_{3}$ & $f_{11}$ & & 1 1 & $(( ))$ & true & $1$\\\n\nTable 2 lists equivalent expressions for the sixteen functions of\nconcrete type $X \\times Y \\to \\mathbb{B}$ and abstract type\n$\\mathbb{B} \\times \\mathbb{B} \\to \\mathbb{B}$ in the same set of\nlanguages.\n\n> [|c|c|c|c|c|c|c|]{}\\\n> $\\mathcal{L}_1$ & $\\mathcal{L}_2$ && $\\mathcal{L}_3$ & $\\mathcal{L}_4$\n> & $\\mathcal{L}_5$ & $\\mathcal{L}_6$\\\n> & & $x =$ & 1 1 0 0 & & &\\\n> & & $y =$ & 1 0 1 0 & & &\\\n> $f_{0}$ & $f_{0000}$ & & 0 0 0 0 & $( )$ & false & $0$\\\n> $f_{1}$ & $f_{0001}$ & & 0 0 0 1 & $(x)(y)$ & neither $x$ nor $y$ &\n> $\\lnot x \\land \\lnot y  $\\\n> $f_{2}$ & $f_{0010}$ & & 0 0 1 0 & $(x) y$ & $y$ and not $x$ &\n> $\\lnot x \\land y$\\\n> $f_{3}$ & $f_{0011}$ & & 0 0 1 1 & $(x)$ & not $x$ & $\\lnot x$\\\n> $f_{4}$ & $f_{0100}$ & & 0 1 0 0 & $x (y)$ & $x$ and not $y$ &\n> $x \\land \\lnot y$\\\n> $f_{5}$ & $f_{0101}$ & & 0 1 0 1 & $(y)$ & not $y$ & $\\lnot y$\\\n> $f_{6}$ & $f_{0110}$ & & 0 1 1 0 & $(x, y)$ & $x$ not equal to $y$ &\n> $x \\ne y$\\\n> $f_{7}$ & $f_{0111}$ & & 0 1 1 1 & $(x y)$ & not both $x$ and $y$ &\n> $\\lnot x \\lor \\lnot y$\\\n> $f_{8}$ & $f_{1000}$ & & 1 0 0 0 & $x y$ & $x$ and $y$ & $x \\land y$\\\n> $f_{9}$ & $f_{1001}$ & & 1 0 0 1 & $((x, y))$ & $x$ equal to $y$ &\n> $x = y$\\\n> $f_{10}$ & $f_{1010}$ & & 1 0 1 0 & $y$ & $y$ & $y$\\\n> $f_{11}$ & $f_{1011}$ & & 1 0 1 1 & $(x (y))$ & not $x$ without $y$ &\n> $x \\Rightarrow y$\\\n> $f_{12}$ & $f_{1100}$ & & 1 1 0 0 & $x$ & $x$ & $x$\\\n> $f_{13}$ & $f_{1101}$ & & 1 1 0 1 & $((x) y)$ & not $y$ without $x$ &\n> $x \\Leftarrow y$\\\n> $f_{14}$ & $f_{1110}$ & & 1 1 1 0 & $((x)(y))$ & $x$ or $y$ &\n> $x \\lor y$\\\n> $f_{15}$ & $f_{1111}$ & & 1 1 1 1 & $(( ))$ & true & $1$\\\n\nThe columns of Tables 1 and 2 are conveniently described in the\nfollowing order:\n\n-   Language $\\mathcal{L}_3$.\n\n    > In Table 1, $\\mathcal{L}_3$ describes each boolean function\n    > $f : \\mathbb{B} \\to \\mathbb{B}$ by means of the sequence of two\n    > boolean values $(f(1), f(0))$.\n    >\n    > In Table 2, $\\mathcal{L}_3$ describes each boolean function\n    > $f : \\mathbb{B}^2 \\to \\mathbb{B}$ by means of the sequence of four\n    > boolean values $(f(1, 1), f(1, 0), f(0, 1), f(0, 0))$.\n    >\n    > Sequences of these forms, perhaps in another order and perhaps\n    > with the logical values F and T instead of the boolean values 0\n    > and 1, would normally be displayed vertically in a truth table\n    > under the column head for $f$.\n\n-   Language $\\mathcal{L}_2$ lists the functions in the form $f_i$,\n    where the index $i$ is a bit string formed from the sequence of\n    boolean values in $\\mathcal{L}_3$.\n\n-   Language $\\mathcal{L}_1$ notates the functions $f_i$ with an index\n    $i$ that is the decimal equivalent of the binary numeral index in\n    $\\mathcal{L}_2$.\n\n    Notice that the sense of the binary and decimal codings is highly\n    dependent on context. One needs to know the number of variables in\n    the function and the sequence of points over which it is evaluated\n    in order to decode the indices properly.\n\n-   Language $\\mathcal{L}_4$ expresses the boolean functions in terms of\n    two families of logical operations:\n\n    > Logical conjunctions written as continued products. For example:\n    >\n    > > $\\begin{array}{ccc}\n    > > x y   & = & x \\land y         \\\\\n    > > x y z & = & x \\land y \\land z \\\\\n    > > \\end{array}$\n    >\n    > Minimal negation operators written as parenthesized lists. For\n    > example:\n    >\n    > > $\\begin{array}{ccc}\n    > > ( )    & = & 0       \\\\\n    > > (x)    & = & \\lnot x \\\\\n    > > (x, y) & = & x \\ne y \\\\\n    > > \\end{array}$\n\n-   Language $\\mathcal{L}_5$ lists ordinary language expressions for the\n    propositional forms. Many other paraphrases are possible, but these\n    afford a sample of the simplest equivalents.\n\n-   Language $\\mathcal{L}_6$ expresses the propositional forms in one of\n    the several notations that are commonly used in formal logic.",
  "language": "INFORMAL",
  "phrase": "Zeroth Order Logic",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/ZerothOrderLogic"
    }
  ],
  "indexable": true
}