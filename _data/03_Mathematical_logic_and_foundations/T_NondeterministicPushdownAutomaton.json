{
  "alternatePhrases": [
    "pushdown automaton",
    "PDA",
    "NPDA",
    "initial stack symbol"
  ],
  "definition": "### Definition {#definition .unnumbered}\n\nA *non-deterministic pushdown automaton* (NPDA), or just *pushdown\nautomaton* (PDA) is a variation on the idea of a non-deterministic\nfinite automaton (NDFA). Unlike an NDFA, a PDA is associated with a\nstack (hence the name *pushdown*). The transition function must also\ntake into account the \u201cstate\u201d of the stack.\n\nFormally defined, a pushdown automaton $M$ is a 7-tuple\n$M=(Q,\\Sigma,\\Gamma,T,q_0,\\bot,F)$, where $Q, \\Sigma, q_0,$ and $F$,\nlike those in an NDFA, are the set of states, the input alphabet, the\nstart state, and the set of final states respectively. $\\Gamma$ is the\n*stack alphabet*, specifying the set of symbols that can be pushed onto\nthe stack. $\\Gamma$ is not necessarily disjoint from $\\Sigma$. $\\bot$ is\nan element of $\\Gamma$ called the *start stack symbol*. The transition\nfunction is\n$$T : Q\\times(\\Sigma\\cup\\{\\lambda\\})\\times\\Gamma\\to\\mathcal{P}(Q \\times \\Gamma^*).$$\n\n### How It Works {#how-it-works .unnumbered}\n\nTo see how the computing machine $M$ works, first imagine $M$ with the\nfollowing features:\n\n1.  a finite set $Q$ of internal states,\n\n2.  a horizontal tape of cells each containing an input symbol of\n    $\\Sigma$,\n\n3.  a tape reader that reads at most one tape cell in any given internal\n    state, and\n\n4.  a vertical stack of cells storing symbols of $\\Gamma$.\n\nNow, given that $M$ is in state $p$, with symbol $A$ on top of the\nstack, and tape reader pointing at a tape cell containing symbol $a$, it\nmay do one of the following:\n\n-   if $T(p,a,A)\\ne \\varnothing$, then it\n\n    1.  \u201cpops\u201d $A$ off the stack,\n\n    2.  \u201cpushes\u201d word $A_1\\cdots A_n$ onto the stack, by starting with\n        symbol $A_n$, and ending with symbol $A_1$,\n\n    3.  \u201cconsumes\u201d $a$ by moving the tape reader to the right of the\n        cell containing $a$, and\n\n    4.  enters state $q$,\n\n    provided that $(q,A_1\\cdots A_n)\\in T(p,a,A)$; if\n    $T(p,a,A)=\\varnothing$, then $M$ does nothing.\n\n-   if $T(p,\\lambda,A)\\ne \\varnothing$, then, without reading $a$, it\n\n    1.  \u201cpops\u201d $A$ off the stack,\n\n    2.  \u201cpushes\u201d word $A_1\\cdots A_n$ onto the stack, and\n\n    3.  enters state $q$,\n\n    as long as $(q,A_1\\cdots A_n)\\in T(p,\\lambda,A)$; if\n    $T(p,\\lambda,A)=\\varnothing$, then $M$ does nothing.\n\nIf $(q,\\lambda) \\in T(p,a,A)$, then $A$ gets popped off, and nothing\ngets pushed onto the stack.\n\n### Modes of Acceptance {#modes-of-acceptance .unnumbered}\n\nA PDA is a language acceptor. We describe how words are accepted by a\nPDA $M$. First, we start with configurations.\n\nA configuration of $M$ is an element of\n$Q\\times \\Sigma^* \\times \\Gamma^*$. For any word $u$, the configuration\n$(q_0,u,\\bot)$ is called the *start configuration* of $u$. A binary\nrelation $\\vdash$ on the set of configurations is defined as follows: if\n$(p,u,\\alpha)$ and $(q,v,\\beta)$ are configurations of $M$, then\n$$(p,u,\\alpha)\\vdash (q,v,\\beta)$$ provided that $\\alpha=A\\gamma$ and\n$\\beta=B_1\\cdots B_n\\gamma$, for some $A,B_1,\\ldots, B_n \\in \\Gamma$,\nand\n\n-   either $u=av$, and $(q,B_1\\cdots B_n)\\in T(p,a,A)$,\n\n-   or $u=v$, and $(q,B_1\\cdots B_n)\\in T(p,\\lambda,A)$.\n\nNow, take the reflexive transitive closure $\\vdash^*$ of $\\vdash$. When\n$(p,u,\\alpha) \\vdash^* (q,v,\\beta)$, we say that $v$ is derivable from\n$u$. A word $u \\in\\Sigma^*$ is said to be\n\n-   accepted on final state by $M$ if\n    $(q_0,u,\\bot) \\vdash^* (q,\\lambda,\\alpha)$ for some final state\n    $q\\in F$,\n\n-   accepted on empty stack by $M$ if\n    $(q_0,u,\\bot) \\vdash^* (q,\\lambda,\\lambda)$,\n\n-   accepted on final state and empty stack by $M$ if\n    $(q_0,u,\\bot) \\vdash^* (q,\\lambda,\\lambda)$ for some $q\\in F$.\n\n### Languages Accepted by a PDA {#languages-accepted-by-a-pda .unnumbered}\n\nGiven a mode of acceptance, the set of words accepted by $M$ is called\nthe language accepted by $M$ based on that mode of acceptance. Given a\nPDA $M$, there are three languages accepted by $M$, corresponding to the\nthree acceptance modes above.\n\nIt turns out that three modes of acceptance are *equivalent*, in the\nfollowing sense: if a language $L$ is accepted by $M$ on one acceptance\nmode, there are PDA $M_1$ and $M_2$ that accept $L$ in the other two\nacceptance modes.\n\nIn general, unless otherwise stated, the language $L(M)$ accepted by a\nPDA $M$ stands for the language accepted by $M$ on final state.\n\n**Remarks**.\n\n1.  Two PDAs are said to be equivalent if they accept the same language.\n    It can be shown that any PDA is equivalent to a PDA where\n    $T(p,\\lambda,A)=\\varnothing$ for all $p\\in F$ and $A\\in \\Gamma$\n    (called a $\\lambda$-free PDA).\n\n2.  One of the main reasons for studying PDA is: the notion of a PDA is\n    equivalent to the notion of a context-free grammar. This means that,\n    every language accepted by a PDA is context-free, and every\n    context-free language is accepted by some PDA.\n\n### Representation by State Diagrams {#representation-by-state-diagrams .unnumbered}\n\nLike an NDFA, a PDA can be presented visually as a directed graph,\ncalled a *state diagram*. Instead of simply labelling edges representing\ntransitions with the leading symbol, two additional symbols are added,\nrepresenting what symbol must be matched and removed from the top of the\nstack (or $\\lambda$ if none) and what symbol should be pushed onto the\nstack (or $\\lambda$ if none). For instance, the notation `a A/B` for an\nedge label indicates that `a` must be the first symbol in the remaining\ninput string and `A` must be the symbol at the top of the stack for this\ntransition to occur, and after the transition, `A` is replaced by `B` at\nthe top of the stack. If the label had been\n$\\verb=a=\\,\\lambda\\verb=/B=$, then the symbol at the top of the stack\nwould not matter (the stack could even be empty), and `B` would be\npushed on top of the stack during the transition. If the label had been\n$\\verb=a=\\,\\verb=A/=\\lambda$, `A` would be popped from the stack and\nnothing would replace it during the transition.\n\nFor example, consider the alphabet\n$\\Sigma := \\left\\{ \\verb=(=, \\verb=)= \\right\\}$. Let us define a\ncontext-free language $L$ that consists of strings where the parentheses\nare fully balanced. If we define $\\Gamma := \\left\\{ A \\right\\}$, then a\nPDA for accepting such strings is:\n\n$$\\UseComputerModernTips\n\\xymatrix {\n\\ar[r] &\n*++[o][F=]{0}\n\\ar@(u,r)[]^{\\texttt{(}\\,\\lambda/\\texttt{A}}\n\\ar@(d,r)[]_{\\texttt{)}\\,\\texttt{A}/\\lambda}\n}$$\n\nAnother simple example is a PDA to accept binary palindromes (that is,\n$\\left\\{ w \\in \\left\\{ 0, 1 \\right\\}^* \\mid w = w^R \\right\\}$).\n\n$$\\xymatrix{\n\\ar[r] &\n*+[o][F-]{0}\n\\ar@(u,r)[]^{0\\,\\lambda/A}\n\\ar@(d,r)[]_{1\\,\\lambda/B}\n\\ar[rrrr]^{\\stackrel{\\lambda\\,\\lambda/\\lambda}{\\stackrel{0\\,\\lambda/\\lambda}{\\stackrel{1\\,\\lambda/\\lambda}{}}}}\n&&&&\n*++[o][F=]{1}\n\\ar@(u,r)[]^{0\\,A/\\lambda}\n\\ar@(d,r)[]_{1\\,B/\\lambda}\n}$$",
  "language": "INFORMAL",
  "phrase": "Non-Deterministic Pushdown Automaton",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/NondeterministicPushdownAutomaton"
    }
  ],
  "indexable": true
}