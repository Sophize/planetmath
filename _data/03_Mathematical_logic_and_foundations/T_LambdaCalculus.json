{
  "alternatePhrases": [],
  "definition": "*Lambda calculus* (often referred to as $\\lambda$-calculus) was invented\nin the 1930s by Alonzo Church, as a form of mathematical logic dealing\nprimarly with functions and the application of functions to their\narguments. In *pure lambda calculus*, there are no constants. Instead,\nthere are only *lambda abstractions* (which are simply specifications of\nfunctions), variables, and applications of functions to functions. For\ninstance, Church integers are used as a substitute for actual constants\nrepresenting integers.\n\nA lambda abstraction is typically specified using a *lambda expression*,\nwhich might look like the following.\n\n$$\\lambda\\;x\\;.\\;f\\;x$$\n\nThe above specifies a function of one argument, that can be *reduced* by\napplying the function $f$ to its argument (function application is\nleft-associative by default, and parentheses can be used to specify\nassociativity).\n\nThe $\\lambda$-calculus is equivalent to combinatory logic (though much\nmore concise). Most functional programming languages are also equivalent\nto $\\lambda$-calculus, to a degree (any imperative features in such\nlanguages are, of course, not equivalent).\n\n### Examples {#examples .unnumbered}\n\nWe can specify the Church integer $3$ in $\\lambda$-calculus as\n\n$$3 = \\lambda f\\;x\\;.\\;f\\;(f\\;(f\\;x))$$\n\nSuppose we have a function $\\operatorname{inc}$, which when given a\nstring representing an integer, returns a new string representing the\nnumber following that integer. Then\n\n$$3\\;\\operatorname{inc}\\;\\texttt{\"0\"} = \\texttt{\"3\"}$$\n\nAddition of Church integers in $\\lambda$-calculus is\n\n$$\\begin{aligned}\n\\operatorname{add}& = & \\lambda\\;x\\;y\\;.\\;(\\lambda\\;f\\;z\\;.\\;x\\;f\\;(y\\;f\\;z)) \\\\\n\\operatorname{add}\\;2\\;3 & = & \\lambda\\;f\\; z\\; .\\; 2\\; f\\; (3\\; f\\; z) \\\\\n        & = & \\lambda\\; f\\; z\\; .\\; 2\\; f\\; (f\\; (f\\; (f\\; z))) \\\\\n        & = & \\lambda\\; f\\; z\\; .\\; f\\; (f\\; (f\\; (f\\; (f\\; z)))) \\\\\n        & = & 5\\end{aligned}$$\n\nMultiplication is\n\n$$\\begin{aligned}\n\\operatorname{mul}& = & \\lambda\\;x\\;y\\;.\\;(\\lambda\\;f\\;z\\;.\\;x\\;(\\lambda\\;w\\;.\\;y\\;f\\;w)\\;z) \\\\\n\\operatorname{mul}\\;2\\;3 & = & \\lambda\\;f\\;z\\;.\\;2\\;(\\lambda\\;w\\;.\\;3\\;f\\;w)\\;z \\\\\n& = & \\lambda\\;f\\;z\\;.\\;2\\;(\\lambda\\;w\\;.\\;f\\;(f\\;(f\\;w)))\\;z \\\\\n& = & \\lambda\\;f\\;z\\;.\\;f\\;(f\\;(f\\;(f\\;(f\\;(f\\;z))))) \\\\\n& = & 6.\\end{aligned}$$\n\n### Russell\u2019s Paradox in $\\lambda$-calculus {#russells-paradox-in-lambda-calculus .unnumbered}\n\nThe $\\lambda$-calculus readily admits Russell\u2019s Paradox. Let us define a\nfunction $r$ that takes a function $x$ as an argument, and is reduced to\nthe application of the logical function $\\operatorname{not}$ to the\napplication of $x$ to itself.\n\n$$r\\;=\\;\\lambda\\;x\\;.\\;\\operatorname{not}\\;(x\\;x)$$\n\nNow what happens when we apply $r$ to itself?\n\n$$\\begin{aligned}\nr\\;r & = & \\operatorname{not}\\;(r\\;r) \\\\\n    & = & \\operatorname{not}\\;(\\operatorname{not}\\;(r\\;r)) \\\\\n    & \\vdots &\\end{aligned}$$\n\nSince we have $\\operatorname{not}\\;(r\\;r) = (r\\;r)$, we have a paradox.",
  "language": "INFORMAL",
  "phrase": "Lambda Calculus",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/LambdaCalculus"
    }
  ],
  "indexable": true
}