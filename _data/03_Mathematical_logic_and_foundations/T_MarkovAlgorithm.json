{
  "alternatePhrases": [],
  "definition": "### Definition {#definition .unnumbered}\n\nA *Markov algorithm* is a variant of a rewriting system, invented by\nmathematician Andrey Andreevich Markov Jr. in 1960. Like a rewriting\nsystem, a Markov algorithm consists of an alphabet and a set of\nproductions. Furthermore, rewriting is done by applying productions one\nat a time, if any. However, unlike a rewriting system, applications of\nproductions are regulated, in the following sense:\n\n-   $P$ is ordered so that, among all applicable productions in a single\n    rewriting step, the first applicable one $x\\to y$ must be used;\n\n-   among all occurrences where rewriting can take place with respect to\n    $x\\to y$, the leftmost occurrence must be applied.\n\nFormally, a *Markov algorithm* is a quadruple\n$\\mathscr{M}=(\\Sigma,P,F,T)$, where\n\n1.  $\\Sigma$ is an alphabet;\n\n2.  $P$ is a non-empty finite ordered set (ordered by, say, $\\le$) of\n    pairs of words over $\\Sigma$, whose elements are called\n    *productions*, and are usually written $x\\to y$ rather than $(x,y)$;\n\n3.  $F$ is a subset of $P$, whose elements are called the *final\n    productions*; and\n\n4.  $T$ is a subset of $\\Sigma$, called the terminal alphabet.\n\n### Rewriting Process {#rewriting-process .unnumbered}\n\nNext, we describe the rewriting process for $\\mathscr{M}$. A production\n$x\\to y$ is *applicable* to a pair $(u,v)$ of words over $\\Sigma$, if\nthere are two words $p,q$ such that $u=pxq$ and $v=pyq$.\n\nA binary relation $\\Rightarrow$ on $\\Sigma^*$ called the *rewriting step\nrelation*, is defined as follows: $u\\Rightarrow v$ iff there is a\nproduction $x\\to y$ such that\n\n1.  $u=pxq$ and $v=pyq$ for some words $p,q$ over $\\Sigma$,\n\n2.  if $(r,s)< (x,y)$, then $r\\to s$ is not applicable to $(u,v)$,\n\n3.  if $u=p'xq'$ and $v=p'yq'$, then $px$ is a prefix of $p'x$.\n\nThe first condition ensures that there is a production ($x\\to y$ in this\ncase) applicable to $(u,v)$, the second condition says that $x\\to y$ is\nthe first available production that can be applied, and the last\ncondition says that the occurrence of $x$ in $u$ is the leftmost.\n\nBy the definition above, every rewriting step $u\\Rightarrow v$\ndetermines a unique production $x\\to y$, called the *associated\nproduction* of $u\\Rightarrow v$.\n\nA word $u$ over $\\Sigma$ is said to be *terminal* if there are no words\n$v$ such that $u\\Rightarrow v$.\n\nA rewriting step is called *final* if its associated production is final\n(in $F$).\n\n### Computation {#computation .unnumbered}\n\nTake the reflexive transitive closure $\\Rightarrow^*$ of $\\Rightarrow$.\nIf $u\\Rightarrow^* v$, we say that $v$ can be *computed* from $u$, or\nthat $v$ is a *computation* from $u$.\n\nGiven any word $u$ over $\\Sigma$, we may iteratively apply rewriting\nsteps to $u$ using the methods described above. Three scenarios may\nemerge:\n\n-   The process terminates: $u\\Rightarrow^* v$, where $v$ is a terminal\n    word;\n\n-   The process reaches a final rewriting step: $u\\Rightarrow^* v$,\n    where the last rewriting step $u_{n-1} \\Rightarrow u_n = v$ is\n    final; or\n\n-   The process never reaches any final rewriting step, and goes on\n    indefinitely.\n\nIf the third scenario occurs, we say that $\\mathscr{M}$ *loops* on $u$.\nOtherwise, $\\mathscr{M}$ *halts* on $u$. In any case, we get a unique\nsequence\n$$u=u_0 \\Rightarrow u_1 \\Rightarrow \\cdots \\Rightarrow u_n \\Rightarrow \\cdots$$\nof rewriting steps $u_i\\to u_{i+1}$. In the first scenario, the sequence\nis finite, and in the third scenario, the sequence is infinite. In the\nsecond scenario, the sequence may be finite or infinite, depending if\nthe rewriting is to be continued after a final rewriting step is reached\n(if $v$ is not a terminal word, then rewriting can continue). Let us\nmake the rule:\n\n> when a final rewriting is reached, no further rewriting is to be done.\n\nThus, the sequence is finite iff $\\mathscr{M}$ halts on $u$. When\n$\\mathscr{M}$ halts on $u$, the finite sequence\n$$u=u_0 \\Rightarrow u_1 \\Rightarrow \\cdots \\Rightarrow u_n = v$$\nproduces a unique word $v$. The word $v$ is said to be *the word\ncomputed by* $\\mathscr{M}$ from $u$. Notice that $v$ is either a\nterminal word, or is computed from a final production $u_{n-1} \\to v$.\nIn either case, no earlier productions $u_i\\to u_{i+1}$ are final.\n\nThus, one can think of a computation by a Markov algorithm as a partial\nfunction $$m_{\\mathscr{M}}:\\Sigma^* \\to \\Sigma^*,$$ where\n$m_{\\mathscr{M}}(u)$ is defined iff $\\mathscr{M}$ halts on $u$, and the\nvalue $m_{\\mathscr{M}}(u)$ is set to *the unique word* $v$ computed by\n$\\mathscr{M}$ from $u$.\n\n### Language Acceptor {#language-acceptor .unnumbered}\n\n$\\mathscr{M}$ can be thought of as a language acceptor, which is the\npurpose of the terminal alphabet $T$: the set\n$$L(\\mathscr{M}):=\\lbrace u\\in T^* \\mid m_{\\mathscr{M}}(u)= \\lambda \\rbrace$$\nis called the *language accepted by* $\\mathscr{M}$. The partial function\n$m_{\\mathscr{M}}$ is defined in the previous section.\n\n**Remark**. It turns out that a Markov algorithm is just another form of\nTuring Machine. One can show that a language is recursively enumerable\niff it can be accepted by a Markov algorithm.\n\nEquivalence to a Turing machine can be restated in terms of functional\ncomputability. Before formalizing this notion, we need to first encode\ntuples of natural numbers by words. Suppose $(n_1,\\ldots,n_m)$ is an\n$m$-tuple of natural numbers. Set\n$$E(n_1,\\ldots,n_m):=ab^{n_1}a b^{n_2} a\\cdots ab^{n_m}a,$$ a word over\nthe alphabet $\\lbrace a,b\\rbrace$. If non-negative integers are allowed\ninstead, we may use the word $E(n_1+1,\\ldots,n_m+1)$ instead.\n\nWe say an $m$-ary number-theoretic partial function\n$f:\\mathbb{N}^m \\to \\mathbb{N}$ is *Markov-computable* if there is a\nMarkov algorithm $\\mathscr{M}$ such that $f(n_1,\\ldots,n_m)$ is defined\niff $m_{\\mathscr{M}}(E(n_1,\\ldots,n_m))$ is defined, and is equal to\n$E(f(n_1,\\ldots,n_m))$.\n\nIt can be shown that a partial function is Turing-computable iff it is\nMarkov-computable.\n\n[9]{} A. Salomaa [*Computation and Automata, Encyclopedia of Mathematics\nand Its Applications, Vol. 25*]{}. Cambridge (1985). N. Cutland,\n[*Computability: An Introduction to Recursive Function Theory*]{}.\nCambridge University Press, (1980). J. D. Monk, *Mathematical Logic*,\nSpringer, New York (1976).",
  "language": "INFORMAL",
  "phrase": "Markov Algorithm",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/MarkovAlgorithm"
    }
  ],
  "indexable": true
}