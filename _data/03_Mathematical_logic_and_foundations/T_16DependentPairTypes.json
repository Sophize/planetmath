{
  "alternatePhrases": [],
  "definition": "Just as we generalized function types () to dependent function types (),\nit is often useful to generalize the product types from to allow the\ntype of the second component of a pair to vary depending on the choice\nof the first component. This is called a [**dependent pair type**]{}, or\n[**$\\Sigma$-type**]{}, because in set theory it corresponds to an\nindexed sum (in the sense of coproduct or disjoint union) over a given\ntype.\n\nGiven a type $A:{\\ensuremath{\\mathcal{U}}\\xspace}$ and a family\n$B : A \\to {\\ensuremath{\\mathcal{U}}\\xspace}$, the dependent pair type\nis written as $\\sm{x:A} B(x) : {\\ensuremath{\\mathcal{U}}\\xspace}$.\nAlternative notations are\n$$\\tsm{x:A} B(x) \\hspace{2cm} \\dsm{x:A}B(x) \\hspace{2cm} \\lsm{x:A} B(x).$$\nLike other binding constructs such as $\\lambda$-abstractions and $\\Pi$s,\n$\\Sigma$s automatically scope over the rest of the expression unless\ndelimited, so e.g.\u00a0$\\sm{x:A} B(x) \\times C(x)$ means\n$\\sm{x:A} (B(x) \\times C(x))$.\n\nThe way to construct elements of a dependent pair type is by pairing: we\nhave ${(a,b)} : \\sm{x:A} B(x)$ given $a:A$ and $b:B(a)$. If $B$ is\nconstant, then the dependent pair type is the ordinary cartesian product\ntype: $${\\Bigl(\\sm{x:A} B\\Bigr)} {\\equiv}(A \\times B).$$ All the\nconstructions on $\\Sigma$-types arise as straightforward generalizations\nof the ones for product types, with dependent functions often replacing\nnon-dependent ones.\n\nFor instance, the recursion principle says that to define a\nnon-dependent function out of a $\\Sigma$-type\n$f : (\\sm{x:A} B(x)) \\to C$, we provide a function\n$g : \\prd{x:A} B(x) \\to C$, and then we can define $f$ via the defining\nequation $$f({(a,b)}) {{\u0703\\!\\!}\\equiv}g(a)(b).$$ For instance, we can\nderive the first projection from a $\\Sigma$-type:\n$${\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}: {\\Bigl(\\sm{x : A}B(x)\\Bigr)} \\to A.$$\nby the defining equation\n$${\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}({(a,b)}) {{\u0703\\!\\!}\\equiv}a.$$\nHowever, since the type of the second component of a pair [$\n  (a,b):\\sm{x:A} B(x)\n$]{} is $B(a)$, the second projection must be a *dependent* function,\nwhose type involves the first projection function:\n$${\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}: \\prd{p:\\sm{x : A}B(x)}B({\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(p)).$$\nThus we need the *induction* principle for $\\Sigma$-types (the\n\u201cdependent eliminator\u201d). This says that to construct a dependent\nfunction out of a $\\Sigma$-type into a family\n$C : (\\sm{x:A} B(x)) \\to {\\ensuremath{\\mathcal{U}}\\xspace}$, we need a\nfunction $$g : \\prd{a:A}{b:B(a)} C({(a,b)}).$$ We can then derive a\nfunction $$f : \\prd{p : \\sm{x:A}B(x)} C(p)$$ with defining equation\n$$f({(a,b)}) {{\u0703\\!\\!}\\equiv}g(a)(b).$$ Applying this with\n$C(p){{\u0703\\!\\!}\\equiv}B({\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(p))$,\nwe can define [$\n{\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}: \\prd{p:\\sm{x : A}B(x)}B({\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(p))\n$]{} with the obvious equation\n$${\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}({(a,b)})  {{\u0703\\!\\!}\\equiv}b.$$\nTo convince ourselves that this is correct, we note that\n$B ({\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}({(a,b)})) {\\equiv}B(a)$,\nusing the defining equation for\n${\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}$, and\nindeed $b : B(a)$.\n\nWe can package the recursion and induction principles into the recursor\nfor $\\Sigma$:\n$${\\mathsf{rec}_{\\sm{x:A}B(x)}} : \\dprd{C:{\\ensuremath{\\mathcal{U}}\\xspace}}{\\Bigl(\\tprd{x:A} B(x) \\to C\\Bigr)} \\to\n{\\Bigl(\\tsm{x:A}B(x)\\Bigr)} \\to C$$ with the defining equation\n$${\\mathsf{rec}_{\\sm{x:A}B(x)}}(C,g,{(a,b)}) {{\u0703\\!\\!}\\equiv}g(a)(b)$$\nand the corresponding induction operator:\n\n[\\_[B(x)]{}]{} : [( C([(a,b)]{}))]{} C(p)\n\nwith the defining equation\n$${\\mathsf{ind}_{\\sm{x:A}B(x)}}(C,g,{(a,b)}) {{\u0703\\!\\!}\\equiv}g(a)(b).$$\nAs before, the recursor is the special case of induction when the family\n$C$ is constant.\n\nAs a further example, consider the following principle, where $A$ and\n$B$ are types and $R:A\\to B\\to {\\ensuremath{\\mathcal{U}}\\xspace}$.\n$${\\ensuremath{\\mathsf{ac}}\\xspace}: {\\Bigl(\\tprd{x:A} \\tsm{y :B} R(x,y)\\Bigr)} \\to\n{\\Bigl(\\tsm{f:A\\to B} \\tprd{x:A} R(x,f(x))\\Bigr)}$$ We may regard $R$ as\na \u201cproof-relevant relation\u201d between $A$ and $B$, with $R(a,b)$ the type\nof witnesses for relatedness of $a:A$ and $b:B$. Then\n${\\ensuremath{\\mathsf{ac}}\\xspace}$ says intuitively that if we have a\ndependent function $g$ assigning to every $a:A$ a dependent pair $(b,r)$\nwhere $b:B$ and $r:R(a,b)$, then we have a function $f:A\\to B$ and a\ndependent function assigning to every $a:A$ a witness that $R(a,f(a))$.\nOur intuition tells us that we can just split up the values of $g$ into\ntheir components. Indeed, using the projections we have just defined, we\ncan define:\n$${\\ensuremath{\\mathsf{ac}}\\xspace}(g) {{\u0703\\!\\!}\\equiv}{\\Bigl(\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x)),\\, \\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}(g(x))\\Bigr)}.$$\nTo verify that this is well-typed, note that if\n$g:\\prd{x:A} \\sm{y :B} R(x,y)$, we have $$\\begin{aligned}\n\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x)) &: A \\to  B, \\\\\n\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}(g(x)) &: \\tprd{x:A} R(x,{\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x))).\\end{aligned}$$\nMoreover, the type\n$\\prd{x:A} R(x,{\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x)))$\nis the result of substituting the function\n$\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x))$\nfor $f$ in the family being summed over in the codomain of\n[$\\mathsf{ac}$]{}:\n$$\\tprd{x:A} R(x,{\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x))) {\\equiv}{\\Bigl(\\lamu{f:A\\to B} \\tprd{x:A} R(x,f(x))\\Bigr)}\\big(\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x))\\big).$$\nThus, we have\n$${\\Bigl(\\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{1}}\\xspace}}\\xspace}(g(x)),\\, \\lamu{x:A} {\\ensuremath{{\\ensuremath{\\mathsf{pr}_{2}}\\xspace}}\\xspace}(g(x))\\Bigr)} : \\tsm{f:A\\to B} \\tprd{x:A} R(x,f(x))$$\nas required.\n\nIf we read $\\Pi$ as \u201cfor all\u201d and $\\Sigma$ as \u201cthere exists\u201d, then the\ntype of the function ${\\ensuremath{\\mathsf{ac}}\\xspace}$ expresses: *if\nfor all $x:A$ there is a $y:B$ such that $R(x,y)$, then there is a\nfunction $f : A \\to B$ such that for all $x:A$ we have $R(x,f(x))$*.\nSince this sounds like a version of the axiom of choice, the function\n[$\\mathsf{ac}$]{}has traditionally been called the [**type-theoretic\naxiom of choice**]{}, and as we have just shown, it can be proved\ndirectly from the rules of type theory, rather than having to be taken\nas an axiom. However, note that no choice is actually involved, since\nthe choices have already been given to us in the premise: all we have to\ndo is take it apart into two functions: one representing the choice and\nthe other its correctness. In we will give another formulation of an\n\u201caxiom of choice\u201d which is closer to the usual one.\n\nDependent pair types are often used to define types of mathematical\nstructures, which commonly consist of several dependent pieces of data.\nTo take a simple example, suppose we want to define a [**magma**]{} to\nbe a type $A$ together with a binary operation $m:A\\to A\\to A$. The\nprecise meaning of the phrase \u201ctogether with\u201d (and the synonymous\n\u201cequipped with\u201d) is that \u201ca magma\u201d is a *pair* $(A,m)$ consisting of a\ntype $A:{\\ensuremath{\\mathcal{U}}\\xspace}$ and an operation\n$m:A\\to A\\to A$. Since the type $A\\to A\\to A$ of the second component\n$m$ of this pair depends on its first component $A$, such pairs belong\nto a dependent pair type. Thus, the definition \u201ca magma is a type $A$\ntogether with a binary operation $m:A\\to A\\to A$\u201d should be read as\ndefining *the type of magmas* to be\n$$\\mathsf{Magma} {{\u0703\\!\\!}\\equiv}\\sm{A:{\\ensuremath{\\mathcal{U}}\\xspace}} (A\\to A\\to A).$$\nGiven a magma, we extract its underlying type (its \u201ccarrier\u201d) with the\nfirst projection ${\\ensuremath{\\mathsf{pr}_{1}}\\xspace}$, and its\noperation with the second projection\n${\\ensuremath{\\mathsf{pr}_{2}}\\xspace}$. Of course, structures built\nfrom more than two pieces of data require iterated pair types, which may\nbe only partially dependent; for instance the type of pointed magmas\n(magmas $(A,m)$ equipped with a basepoint $e:A$) is\n$$\\mathsf{PointedMagma} {{\u0703\\!\\!}\\equiv}\\sm{A:{\\ensuremath{\\mathcal{U}}\\xspace}} (A\\to A\\to A) \\times A.$$\nWe generally also want to impose axioms on such a structure, e.g.\u00a0to\nmake a pointed magma into a monoid or a group. This can also be done\nusing $\\Sigma$-types; see .\n\nIn the rest of the book, we will sometimes make definitions of this sort\nexplicit, but eventually we trust the reader to translate them from\nEnglish into $\\Sigma$-types. We also generally follow the common\nmathematical practice of using the same letter for a structure of this\nsort and for its carrier (which amounts to leaving the appropriate\nprojection function implicit in the notation): that is, we will speak of\na magma $A$ with its operation $m:A\\to A\\to A$.\n\nNote that the canonical elements of $\\mathsf{PointedMagma}$ are of the\nform $(A,(m,e))$ where $A:{\\ensuremath{\\mathcal{U}}\\xspace}$,\n$m:A\\to A\\to A$, and $e:A$. Because of the frequency with which iterated\n$\\Sigma$-types of this sort arise, we use the usual notation of ordered\ntriples, quadruples and so on to stand for nested pairs (possibly\ndependent) associating to the right. That is, we have\n$(x,y,z) {{\u0703\\!\\!}\\equiv}(x,(y,z))$ and\n$(x,y,z,w){{\u0703\\!\\!}\\equiv}(x,(y,(z,w)))$, etc.",
  "language": "INFORMAL",
  "phrase": "1.6 Dependent Pair Types",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/16DependentPairTypes"
    }
  ],
  "indexable": true
}