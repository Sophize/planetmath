{
  "alternatePhrases": [
    "course-of-value",
    "course-of-values"
  ],
  "definition": "In defining a function by primitive recursion, the value of the next\nargument $f(n+1)$ depends only on the value of the current argument\n$f(n)$. Definition of functions by course-of-values recursion, $f(n+1)$\ndepends on value(s) of some or all of the preceding arguments\n$f(n),\\ldots, f(0)$. Two very basic examples of definition by\ncourse-of-values recursion are\n\n1.  (Fibonacci numbers). $F(0)=F(1)=1$, and $F(n+1)=F(n)+F(n-1)$.\n\n2.  $f(0)=1$, and $f(n+1)=f(n)+f(n-1)+\\cdots + f(0)$.\n\nIn the first example, we may write $F(n+1)= g(F(n),F(n-1))$, where $g$\nis the familiar addition function, a function of two arguments. In other\nwords, value of the current argument of $F$ depends on the values of a\nfixed number of preceding arguments (in this case, $2$). In the second\nexample, value of the current argument of $f$ depends on the values of\nall of the values of the preceding arguments. Suppose we write\n$f(n+1)=h(f(n),\\ldots, f(0))$, where $h$ is the $(n+1)$-ary addition\nfunction. This $h$ is different from $g$ in the sense that $g$ has a\nfixed arity, whereas the arity of $h$ depends on the argument of $f$. In\nother words, as $n$ varies, a \u201cdifferent\u201d $h$ is required! Is it\npossible to define $f$ via a fixed function as in the first example?\nMoreover, what is the relation between course-of-values recursion and\nprimitive recursion?\n\nThe answer to the first question is yes. To get around the difficulty of\n\u201cvarying arity\u201d, we employ the technique of encoding the entire sequence\nof values of the preceding arguments of $f$ by a \u201ccode number\u201d, and come\nup with a function $h$ that depends on the this code number. $h$ then\ncan be used to define $f$.\n\nPick an encoding of finite sequences of non-negative integers,\npreferably a primitive recursive encoding. As usual, we set\n$$\\langle a_1, \\ldots, a_m \\rangle$$ as the code, or sequence number of\nthe sequence $a_1, \\ldots, a_m$, and if\n$x= \\langle a_1, \\ldots, a_m \\rangle$, we set $(x)_i:=a_i$ if $i\\le m$,\nand $0$ otherwise.\n\nFor this entry, we choose the multiplicative encoding of G\u00f6del (see for\nmore detail) because of its convenience. Then\n$$\\langle a_1, \\ldots, a_m \\rangle := p_1^{s(a_1)} \\cdots p_m^{s(a_m)},$$\nwhere $p_i$ is the $i$-th prime number, and $\\langle \\rangle:=1$.\n\n**Definition**. For any function $f:\\mathbb{N}^{k+1}\\to \\mathbb{N}$,\ndefine the *course-of-values function* $\\overline{f}$ of $f$ as follows:\n$\\overline{f}$ has the same arity as $f$, and for any\n$\\boldsymbol{x}\\in \\mathbb{N}^k$,\n\n1.  $\\overline{f}(\\boldsymbol{x},0):=\\langle \\rangle $, and\n\n2.  $\\overline{f}(\\boldsymbol{x},y+1):= \\langle f(\\boldsymbol{x},0), \\ldots, f(\\boldsymbol{x},y)\\rangle$.\n\nFor example, if $F(n)$ is the $n$-th Fibonacci number, then\n$\\overline{F}(0)=1$, $\\overline{F}(1)=\\langle 1 \\rangle = 4$, and\n$\\overline{F}(2)=\\langle 4,1 \\rangle = 2^5\\cdot 3^2 = 288$, etc... It is\nevident that $\\overline{F}$ grows very rapidly.\n\n**Definition**. A function $f:\\mathbb{N}^{k+1}\\to \\mathbb{N}$ is said to\nbe defined by *course-of-values recursion* via function\n$h:\\mathbb{N}^{k+2} \\to \\mathbb{N}$ if, for any\n$\\boldsymbol{x} \\in \\mathbb{N}^k$:\n$$f(\\boldsymbol{x},y) = h(\\boldsymbol{x},y, \\overline{f}(\\boldsymbol{x},y) ).$$\n\nThe two examples above are defined by course-of-values recursion:\n\n-   $F(n)=h(n,\\overline{F}(n))$, where\n    $h(x,y): = (y)_x + (y)_{x \\dot{-} 1}$.\n\n-   $f(n)=h(n,\\overline{f}(n))$, where\n    $ h(x,y)= \\sum_{i=0}^{x \\dot{-}1} (y)_i$.\n\nThe second question posed at the beginning can now be answered:\n\n$f$ is primitive recursive iff $\\overline{f}$ is.\n\nBy definition, and using multiplicative encoding, we have\n$\\overline{f}(\\boldsymbol{x},0):=\\langle \\rangle=1 $, and\n$$\\overline{f}(\\boldsymbol{x},y+1):= p_1^{f(\\boldsymbol{x},0)} \\cdots p_{y+1}^{f(\\boldsymbol{x},y)} = \\overline{f}(\\boldsymbol{x},y) p_{y+1}^{f(\\boldsymbol{x},y)}$$\nThus, if $f$ is primitive recursive, so is $\\overline{f}$ by primitive\nrecursion. Conversely, if $\\overline{f}$ is primitive recursive, so is\n$f(\\boldsymbol{x},y)=(\\overline{f}(\\boldsymbol{x},y+1))_{y+1}$.\n\nIf $h: \\mathbb{N}^{k+1} \\to \\mathbb{N}$ is primitive recursive, so is\n$f$ defined by course-of-values recursion via $h$.\n\nFrom the proof of the proposition above, we see that\n$$\\overline{f}(\\boldsymbol{x},y+1)= \\overline{f}(\\boldsymbol{x},y) p_{y+1}^{f(\\boldsymbol{x},y)} = \\overline{f}(\\boldsymbol{x},y) p_{y+1}^{h(\\boldsymbol{x},y, \\overline{f}(\\boldsymbol{x},y))}.$$\nThus, as $h$ is primitive recursive, so is $\\overline{f}$ by primitive\nrecursion, and hence $f$ is primitive recursive by the previous\nproposition.\n\n**Remark**. If the value of the next argument of $f$ depends on values\nof a fixed set of prior arguments, then the primitive recursiveness of\n$f$ can be proved via mutual recursion. For example, suppose\n$f(k+1)=h(f(k-1),f(k-3),f(k-4))$. By setting $f_i(n):=f(n+i)$ for\n$i=0,1,2,3$, we see that\n$$f_i(n+1)=f(n+i+1)=f_{i+1}(n) \\quad \\mbox{for }i=0,1,2.$$ Furthermore,\n$$\\begin{aligned}\nf_3(n+1) &=&  f_0(n+4)=f(n+4)=h(f(n+2),f(n+1),f(n)) \\\\ &=& h(f_0(n+2),f_0(n+1),f_0(n))=h(f_2(n),f_1(n),f_0(n)).\\end{aligned}$$\nSo the $f_i$ are defined by mutual recursion, and if $h$ is primitive\nrecursive, so is each $f_i$.",
  "language": "INFORMAL",
  "phrase": "Course-Of-Values Recursion",
  "remarks": "",
  "citations": [
    {
      "textCitation": "https://planetmath.org/CourseofvaluesRecursion"
    }
  ],
  "indexable": true
}